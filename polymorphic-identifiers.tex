%-----------------------------------------------------------------------------
%
%    Domain Specific Identifiers
%
%-----------------------------------------------------------------------------


\documentclass[preprint,authoryear]{llncs}


\usepackage{ifthen}
\usepackage{pifont}
%\usepackage[small,compact]{titlesec}

\usepackage{mathptmx}

\usepackage{paralist}

\usepackage[small,it]{caption}

\usepackage[pdftex]{graphicx}
\usepackage{fancyhdr}


\usepackage{amsmath}
\usepackage{epigraph}
\usepackage[colorlinks=true,
        linkcolor=blue,
        citecolor=red,
        filecolor=black,
        pagecolor=black,
        urlcolor=black,
        bookmarks=true,
        bookmarksopen=true,
        bookmarksopenlevel=3,
        plainpages=false,
        pdfpagelabels=true]{hyperref}

%%--- listings configuration
\usepackage{listings}
\lstset{
  language={C},
  basicstyle=\ttfamily,
  keywordstyle=\bfseries,
  showstringspaces=false,
  commentstyle=,
  captionpos=below%,
%  numbers=left,
%  numberstyle=\tiny,
%  numbersep=5pt
}
\lstset{numberbychapter=false}

%\lstdefinestyle{L}{basicstyle=\ttfamily}
\lstdefinestyle{L}{basicstyle=\ttfamily\scriptsize}
\lstdefinestyle{numbers}
{numbers=left, stepnumber=1, numberstyle=\tiny, numbersep=10pt,basicstyle=\ttfamily\scriptsize}

%%--- end of listings configuration

\pagestyle{fancy} 
% \sloppy

%\setlength{\parskip}{0pt}
%\setlength{\parsep}{0pt}
%\setlength{\headsep}{2pt}
%\setlength{\topskip}{0.1pt}
%\setlength{\topmargin}{1pt}
%\setlength{\topsep}{1pt}
%\setlength{\partopsep}{0pt}

\newboolean{showcomments}
\setboolean{showcomments}{true}



\ifthenelse{\boolean{showcomments}}
  {\newcommand{\mynote}[2]{
      {\color{red}
    \fbox{\bfseries\sffamily\scriptsize#1}
%       {\small$\blacktriangleright$\textsf{\emph{#2}}$\blacktriangleleft$}
       {\small \textsf{\emph{#2}} }
    % \marginpar{\fbox{\bfseries\sffamily#1}}
        }
   }
   \newcommand{\cvsversion}{\emph{\scriptsize $ $Revision: 1.42 $ $ -- $ $Date: 2005/10/01 00:23:32 $ $ }}
  }
  {\newcommand{\mynote}[2]{}
   \newcommand{\cvsversion}{}
  }

\newcommand{\here}{\mynote{***}{CONTINUE HERE}}
\newcommand\nb[1]{\mynote{NB}{#1}}
\newcommand\fix[1]{\mynote{FIX}{#1}}
% \newcommand\todo[1]{\mynote{TO DO}{#1}}
\newcommand\mpw[1]{\mynote{Marcel}{#1}}
\newcommand\rh[1]{\mynote{Robert}{#1}}




\begin{document}
\fontsize{9.8}{12}\rm

\linespread{0.9}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2011} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.


\title{Polymorphic Identifiers\\--ECOOP 2013 DRAFT--}
\subtitle{Unified resource access in Objective-Smalltalk}

\author{Marcel Weiher\inst{1} \and Robert Hirschfeld\inst{2}}
\institute{metaobject ltd. \email{marcel@metaobject.com} \and Hasso Plattner Institut \email{robert.hirschfeld@hpi.uni-potsdam.de}}


%\numberofauthors{2}
%\author{
%\alignauthor Marcel Weiher\\
%       \affaddr{metaobject ltd.}\\
%       \email{marcel@metaobject.com}
%\alignauthor Robert Hirschfeld\\
%       \affaddr{Hasso Plattner Institut}\\
%       \email{}
%}

\maketitle

\begin{abstract}

\emph{Polymorphic Identifiers} provide a uniform mechanism for accessing resources
no matter whether they are in-process or external, local or remote, built-in or custom-defined,
supporting abstraction, custom semantics and resource-oriented programming styles.

Existing identifier mechanisms built into programming languages
appear to be insufficient, because these mechanisms are
frequently bypassed by developers 
building their own string-based identifiers and evaluation mechanisms,
especially when referring to external resources.

Embedding ad-hoc little languages
as strings into a host language has many drawbacks, such as
lack of integration, incompatibilities hampering substitutability,
lack of expressiveness and runtime overhead.

We propose to address these issues by bringing extensible resource access  into
the programming language using \emph{Polymorphic Identifiers}:    Existing language identifier syntax is
replaced by a little language based on Universal Resource Identifier (URI)~\cite{rfc3986}
syntax and identifier evaluation made extensible with Open Implementation
techniques~\cite{OpenImplementations} using pluggable handlers for URI schemes and first
class references to mediate access.
  


\end{abstract}

% \category{D.3.3}{Programming Languages}{Language Constructs and Features}

%\terms{language, design}
%\keywords{Polymorphic Identifiers} % NOT required for Proceedings
%\setlength{\epigraphrule}{0pt}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Introduction}

Beginning with low-level assembly language, programming languages have built-in mechanisms for 
referring to resources used by the program using human readable names, be they symbolic addresses or variable
names.   However, despite having these identifiers built-in, resource access
is often mediated by user-defined, string-based identifiers that are separate from built-in identifiers,
cannot generally be used interchangeably and don't share implementation.  This is especially true
of external resources such as files or web-pages, but also of program-internal resources that need to
be referenced by parameter or require additional behavior.

Although part of the reason may well be familiarity and the weight of existing, string-based APIs such as POSIX,
limitations of built-in identifiers also play a role:   what kinds of resources can be accessed directly by name is
highly dependent on the programming language in question, and cannot be easily 
adapted to a particular requirement.  The syntax of built-in identifiers does not lend itself to representing
files or URIs, and the lookup mechanism tends to be fixed, for example to avoid confusion as to the
meaning of local identifiers~\cite{gabriel-lisp-identifiers}.




Our starting point is the Objective-Smalltalk \cite{objst} dialect of Smalltalk, which has objects
that communicate via messages\cite{Goldberg1983}, but the identifiers that are used to identify 
objects are early bound by the compiler.  Late-binding of names, encapsulation,
and polymorphic behavior can only be achieved via message-sends.


Identifiers that need to point to other entities or be used in different ways must be defined
by the programmer and cannot be used interchangeably with built in identifiers.  

The contributions of this paper are the following:
\begin{enumerate} 

\item a uniform, composable and extensible resource access mechanism for all
resources in a program, 
\item  a way of integrating that access mechanism naturally into the language for
direct, \emph{identifier oblivious} access and
\item a uniform treatment of references for indirect, \emph{identifier aware} access.
\end{enumerate}



In Section~\ref{identifiers}, we briefly illustrate some of the issues that lead developers to use string-based
identifiers and then show some of 
the problems string-based identifiers cause.  In Section~\ref{polymorphic-identifiers}, we 
introduce \emph{Polymorphic Identifiers} as a reification, abstraction and extension of existing 
identifier lookup mechanisms.  After that we look at components of the Polymorphic Identifier (PI)
system, \emph{scheme resolvers} (section~\ref{schemes}), first class \emph{references} (section~\ref{references}),
parametrized identifiers (section~\ref{parametrized}), and  implementation aspects (section~\ref{implementation}).
In Section~\ref{evaluation} we evaluate the Polymorphic Identifiers and discuss related work in Section~\ref{related-work}.


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%





\section{Identifiers}
\label{identifiers}
%\epigraph{When programming a component, the right computation model for the component is the least expressive model that results in a natural program.}{Rule of Least Expressiveness.}


Identifiers that name resources come in many different forms ranging from local,
global or instance variables to names for disk files or Universal Resource Identifiers (URIs)~\cite{rfc3986} pointing to network resources.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5,page=1]{basic-storage.pdf}
\caption{Generic identifier lookup}
\label{identifier-eval}
\end{figure}

Whatever the specific type, the relationship between the actual identifier and the
final value looks like Figure~\ref{identifier-eval}, with slight variations:   there is 
the identifier itself, which is a human-readable character string, there is some kind
of store that has identifiable slots or cells and there is a value stored in one of those
cells.   In order to retrieve a value, the human-readable identifier is first converted to a machine-readable reference using a
 \emph{reference(identifier)} function and then the reference is used to look up an actual
value from a slot using the \emph{get(reference(identifier))} function.



\subsection{Built-in identifiers}
\label{direct-reference}

Like most programming languages, Smalltalk allows you to just write 
an identifier by itself, and this will perform an implicit {\tt get} operation, automatically retrieving the value stored in the slot referenced by the identifier, for
example line 1 of Listing~\ref{variable-lookup} for the identifier {\tt theAnswer}.
Storing into the slot is accomplished with
the assignment operator {\tt :=} shown in line 2, which is equivalent to a {\tt set} operation.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=variable-lookup,caption=Retrieve and store value via plain identifier.]
theAnswer.
theAnswer := 42.
\end{lstlisting}
\end{figure}

Plain identifiers are bound early and resolved directly.  
Developers cannot extend them to refer to
new types of objects such as files or define new access mechanisms.  Dave Robson, one of the authors
of the Blue Book defining Smalltalk \cite{Goldberg1983} is reported by Ungar and Smith in \cite{Ungar:2007:SEL:1238844.1238853} to have said: ``Yeah, once youÕre inside an object, itÕs pretty much like Pascal.''


Encapsulation and the potential for polymorphic behavior can be achieved by sending 
messages to objects in order to get and set the value in question, for example the
{\tt deepThought}~\cite{adams1997hitchhiker}  object in Listing~\ref{message-access}.  Languages
with implicit receivers such as Self and Newspeak can (and must) elide the receiver.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=message-access,caption=Retrieve and store value via message sends.]
  deepThought getTheAnswer.
  deepThought setTheAnswer:42.
\end{lstlisting}
\end{figure}

Unlike plain identifiers, actual resource access is fully under developer control, so sending the 
message {\tt getTheAnswer} can can invoke a method that just retrieves a value from an instance
variable, reads it from a file or computes it for the next hundred million years.


This added flexibility comes at the cost of tangling resource names with the operations on those
resources (  $({\tt get}|{\tt set}) \times {\mbox{\em resourceName}} ) $ %= ({\tt getTheAnswer},{\tt setTheAnswer}) $), thus
increasing the number of identifiers by a factor of two and also scattering the resource access code
throughout individual accessor methods such as the
ones in Listing~\ref{trivial-accessors}.  
%and though the paper argues that this 5\% of code is \emph{not} enough
%to warrant special treatment,  the prevalence of polymorphic message sends is also around 5\% according to~\cite{Holzle:1991:ODO:646149.679193}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=trivial-accessors,caption=Trivial accessors.]
getTheAnswer
    ^theAnswer.
setTheAnswer:newAnswer
    theAnswer := newAnswer.
\end{lstlisting}
\end{figure}

These trivial accessors can account for 5\% of Java code~\cite{Spinellis:2002:MPC:510857.510868}, and although 
 automatic generation can lessen the burden, it doesn't help the fundamental brittleness of 
having resource access scattered throughout the code-base: if we want to implement an alternative resource access scheme or 
access to other kinds of resources such as files, we  have to implement or update the accessor methods for each specific resource individually,
rather than once for each resource type or access methods as a whole.

Creating references is possible with message-based identifiers, but requires not just
storing the base object, but also both the get and the set accessor message names,
as shown in Figure~\ref{ui-widget-msg-access} for a UI widget that is connected
to the {\tt theAnswer} attribute of the {\tt deepThought} object.




\subsection{Strings as identifiers}
\label{string-identifiers}
Using strings as identifiers disentangles the identifier from the access operations, but at the cost
of additional syntactic elements at each call site, as shown in Listing~\ref{kvc-literal-string} using the Cocoa~\cite{Cocoa}
\emph{Key Value Coding} (KVC)~\cite{KVC} protocol.   Unlike Smalltalk's {\tt instVarNamed:} 
messages, which directly accesses instance variables, KVC uses accessor messages derived
from the identifier when available, therefore maintaining encapsulation.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=kvc-literal-string,caption=Retrieve and store value via string identifier.]
deepThought valueForKey:'theAnswer'.
deepThought setValue:42 forKey:'theAnswer'.
\end{lstlisting}
\end{figure}

Separating identifiers from their access methods allows new object types or stores to be referenced by redefining
the access methods once, without having to do additional work for each individual resource, a clear advantage
over message-based identifiers.  It also allows external resources to be referenced, which is why string-based
identifiers are the de-facto standard for referencing files or web resources.

 However, Listing~\ref{kvc-literal-string} already shows one disadvantage:  whereas
plain identifiers need just one element to reference a value, the identifier, and message-based identifiers need two,
the object and the message, string-based identifiers need three:  the object, the access method that interprets the
string and the string identifier itself.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=string-identifiers-custom,caption=Retrieve and store value with custom stores.]
aDictionary objectForKey:'theAnswer'.
aDictionary setObject:42 forKey:'theAnswer'.
\end{lstlisting}
\end{figure}
%NSDefaults standardUserDefaults objectForKey:'theAnswer'.
%NSDefaults standardUserDefaults setObject:'42' forKey:'theAnswer'.



In addition to the syntactic overhead at each call-site, this requirement to separately specify the interpreter
for the string identifier opens the way to having a separate interpreter for each type of store. 
Listing~\ref{string-identifiers-custom} shows this effect for Cocoa dictionaries, which use a set of messages for
access ({\tt objectForKey:} and {\tt setObject:forKey:}) that is different from the KVC messages above, meaning
 that dictionaries and objects are not interchangeable.  
The same differences apply to Smalltalk collections and objects which use {\tt at:} and {\tt at:put:} vs. {\tt instVarNamed:} and {\tt instVarNamed:put:}
respectively.

\sloppy		%  FIXME

File system access uses yet another set of messages, coupling code that wishes to use the filesystem tightly to the filesystem,
rather than having interchangeable resource providers.  Whereas raw bytes can be read from disk using
{\tt NSData dataWithContentsOfFile:'theAnswer.txt'} and strings using 
{\tt NSString stringWithContentsOfFile:'theAnswer.txt'},  Listing~\ref{drawing-image-from-file} shows two different methods
for loading an image from the file-system for drawing on a graphics context, the first directly from a filesystem path,
the second using a specialized method for obtaining named images from the application's resources.

\fussy

%'42' writeToFile:'theAnswer.txt' atomically:YES.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=drawing-image-from-file,caption=Drawing an image stored in a file.]
context drawImage:(UIImage imageWithContentsOfFile:'answerImage.png').
context drawImage:(UIImage imageNamed:'pictureOf42').
\end{lstlisting}
\end{figure}


Another problem with strings is that access paths frequently have to be composed from a combination of system-provided base paths
and fixed as well as variable components, using string processing, for example computing the location of a specific RFC relative
to a directory in the user's home directory  ({\tt \$HOME/rfcs/\$rfcName}) as shown in Listing~\ref{rfcs-directory}.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=rfcs-directory,caption=Accessing a specific RFC in a directory relative to the user's \$HOME.]
home := NSProcessInfo processInfo environment objectForKey:'HOME'.
rfcDir  := home stringByAppendingPathComponent:'rfcs'.
rfcPath := rfcDir stringByAppendingPathComponent:rfcName.
rfcText := NSString stringWithContentsOfFile:rfcPath.
\end{lstlisting}
\end{figure}


For references, Figure~\ref{ui-widget-string-access} shows how KVC simplifies parametrized access for 
the client:  instead of having to specify two messages, the getter and the setter, a single string key can be used with
the two generic access methods.  The actual access mechanism is a little more complicated, but this is hidden and can 
be reused.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.4,page=1]{ui-widget-generic-access-string.pdf}
\caption{Widget using string identifiers for parametrized access}
\label{ui-widget-string-access}

\end{figure}

Finally, evaluating string identifiers at run-time also imposes overhead.

\subsection{Reified references}

Unlike strings, reified references can be semantically rich and self-contained, 
allowing variations without requiring a separate evaluator.
Unlike messages they can encapsulate both read and write access in one entity.  

Figure~\ref{ui-widget-valueholder} shows how a \emph{ValueHolder}~\cite{Woolf:1995:UUV:218662.218699} object,
specifically an {\em AspectAdaptor} that
references a specific attribute of the base object, reduces the entities the widget
needs to interact with to one, from three in the case of message-based identifiers and two
in the case of string-based identifiers.  How the ValueHolder accesses 
its underlying data is completely hidden from clients, so different containers or access
strategies can be substituted without having to modify client code.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.4,page=1]{ui-widget-valueholder.pdf}
\caption{Widget using ValueHolder for parametrized access}
\label{ui-widget-valueholder}

\end{figure}

Listing~\ref{reified-identifiers} demonstrates the drawback of ValueHolders:  even greater complexity at the
call site, making direct use impractical. 


\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=reified-identifiers,caption=Retrieve and store value via AspectAdaptor ValueHolder.]
((AspectAdapter subject:deepThought) forAspect:#theAnswer) value.
((AspectAdapter subject:deepThought) forAspect:#theAnswer) value:42.
\end{lstlisting}
\end{figure}

Cocoa's {\tt NSURL} class is used to access resources referenced by URI and suffers from similar complexity
of use at the call-site.  Listing~\ref{nsurl-flickr-draw}
shows the complete process for drawing an image with a specific ID from flickr on a graphics context.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=nsurl-flickr-draw,caption=Retrieving and drawing an image stored on flickr.com.]
flickrURL :=NSURL URLWithString:'http://static.flickr.com/2438/'.
imageURL := NSURL URLWithString:'3559417932_7208103ed8_m.jpg'
                  relativeToURL:flickrBase.
imageData := NSData dataWithContentsOfURL:imageURL.
context drawImage: (UIImage imageWithData:imageData).
\end{lstlisting}
\end{figure}


A final problem, apart from the loss of directness and expressiveness, is that we have now 
duplicated the identifier lookup mechanism built into the language (see Figure~\ref{identifier-eval})
in user space.  Such code duplication should be avoided, but we are prevented from applying refactoring
to implement on in terms of the other by the fact that one is hard-wired into the language and the other is not.

\subsection{Discussion}

Although resource access is one of the most basic operations in a programming language, combining it
with features we have come to expect from object-orientation such as encapsulation, polymorphic
behavior and user-extensibility turns out to be surprisingly difficult.  

Plain identifiers simply do not have the required features, and messaging by itself is limited
by combining resource names with operations, causing code bloat and brittleness.

Using strings as identifiers does meet our basic goals of allowing changes, but suffers from
code-bloat at the call sites, lack of interoperability and runtime evaluation overhead.  Reified 
identifiers improve interoperability and can reduce overhead for reference use, but are 
sufficiently cumbersome as to be unusable as direct identifiers.

A solution would need to combine the expressiveness of direct references, the universality
of polymorphic message sends with flexibility of string-based identifiers.


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Polymorphic Identifiers}
\label{polymorphic-identifiers}
%\epigraph{A change in perspective is worth 80 IQ points}{Alan Kay}

Polymorphic Identifiers generalize direct references by combining the techniques for resource access
discussed in the previous section such as reifying the identifier lookup process and using messaging 
to make it polymorphic, in addition to expanding identifier syntax to accommodate extension and 
opening up the language for extension at this point  with open-implementation techniques~\cite{OpenImplementations}.

The generalization from plain identifiers to Polymorphic Identifiers is similar to that from early-bound
function calls to late-bound messages.

Listing~\ref{polymorphic-identifier-examples} recasts the examples from Section~\ref{identifiers} using
Polymorphic Identifiers.  Lines 1-2 refer to a local resource, lines 3-4 to attributes of an object or 
entries in a dictionary, the syntax is the same.  Lines 5 introduces a custom scheme for the persistent
user defaults, whereas lines 6-8 show file system access and lines 9-10 access to network resources.



\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=polymorphic-identifier-examples,caption=Retrieve \mbox{[and store]} values via Polymorphic Identifiers.]
theAnswer [:=42 ].
var:theAnswer [ :=42 ].
var:deepThought/theAnswer [:= 42. ]
var:aDictionary/theAnswer [ := 42.]
defaults:theAnswer [ := 42 ].
file:theAnswer.txt [ := 42 ].
file:answerImage.png.
img:pictureOf42.
http://www.depthought.com/theAnswer.
ref:http://www.depthought.com/theAnswer.
\end{lstlisting}
\end{figure}

The syntax for accessing these different types of resources is identical, even if the actual
names differ, and storing values into the resources is always accomplished using the assignment operator.
As it is possible to (re-)bind scheme names to existing or new schemes, all these different access 
mechanism are interoperable and can be substituted for one another.

The Polymorphic Identifier approach consists of three basic parts:
\begin{enumerate}
\item \emph{Polymorphic Identifiers} themselves are URIs\footnote{Other syntax variants such as dot notation should also work.}.
	  They are typically created by the 
	compiler and have a structured runtime representation that can be manipulated
	at a semantic level rather than as character strings, so consistency can be 
	maintained.
\item \emph{Scheme-handlers} manage a set of resources and, when registered,
	 the namespace that is associated
	with them.  They primarily turn \emph{Polymorphic Identifiers} into \emph{references} and
	are created by developers, with a basic set provided by the environment.
\item \emph{References} are created and used transparently by the run-time and compiler
	to mediate access to the specific resource identified by a \emph{Polymorphic Identifier}.
	
	
\end{enumerate}

All three elements are plain objects that only become part of the language when registered
with the compiler or runtime.

Figure~\ref{scheme-eval} shows the generic identifier lookup of Figure~\ref{identifier-eval}
extended to Polymorphic Identifiers.  The basic mechanism is still the same except for the
addition of \emph{scheme-handlers} mediating the lookup process.  The left hand side of the
diagram corresponds to the lookup in Figure~\ref{identifier-eval}, with the difference that
the lookup that was previously hardwired into the language is now mediated by the {\tt var}
scheme-handler, which in turn was selected by the {\tt var} scheme that's part of the 
Polymorphic Identifier.


\begin{figure}[htbp]
\centering\includegraphics[scale=0.45,page=1]{scheme-evaluation.pdf}
\caption{Polymorphic Identifier lookup from two schemes}
\label{scheme-eval}
\end{figure}


The right hand side of Figure~\ref{scheme-eval} shows fetching of a web-resource from
a remote server following the same four step lookup process, with the following steps:

\begin{enumerate}
\item a character sequence is turned into a Polymorphic Identifier,
\item the scheme part of the polymorphic handler is used to select a scheme-handler, in this case the {\tt http} handler,
\item the scheme-handler evaluates the \emph{scheme-specific} part of the Polymorphic Identifier ({\tt //deepThought.org/theAnswer})
	 and returns a reference, in this case a web-reference,
\item this (web-)reference mediates access to the actual resource, in this case translating requests to store or retrieve the 
	resource into HTTP GET or PUT requests via an http client library.
\end{enumerate}

These four steps can happen at compile-time or run-time and can be partially completed.
A reference to a local stack variable, for example, will typically have none of the
three components visible at run time, with all that remains being optimized 
machine code to directly access the resource (the stack variable).
A file or web-reference, on the other hand, will typically have the Polymorphic Identifier itself
compiled, with evaluation deferred until runtime.  Finally, there are facilities
for turning strings into Polymorphic Identifiers at runtime.


\section{Schemes and scheme-handlers}
\label{schemes}
The addition of \emph{schemes} to identifiers in order to distinguish different kinds of resources
and resource access represents
the major addition that \emph{Polymorphic Identifiers} bring to a programming language.
Each scheme is backed by a \emph{scheme-handler}.  Scheme-handlers broadly fall into two categories:
 \emph{primitive schemes} (section~\ref{primitiveSchemes})
directly encapsulate access to some sort of resource, while \emph{composite schemes} (section~\ref{compositeSchemes})
can be used to build new schemes out of existing schemes, forming a scheme algebra.

\sloppy   % FIXME

Scheme-handlers are represented by normal objects that respond to a well-defined protocol 
accessible by user level code.  They
become part of the language by binding them to a particular scheme, after which
all \emph{Polymorphic Identifiers} with that scheme will be resolved using that particular scheme-handler.
The {\tt scheme:} scheme manages the mapping of scheme-names to scheme-handlers, so the code 
{\tt scheme:http := URLSchemeResolver scheme} binds an instance of the {\tt URLSchemeResolver} class
to the {\tt http:} scheme.

\fussy

 Any scheme-handler
can be used for any scheme-name, as long as it implements the handler protocol
compatibly.


The \emph{scheme scheme} can also be queried,
so the expression {\bf scheme:http} returns the currently installed http handler, and 
{\bf scheme:scheme} returns the scheme scheme itself, which will list the currently
installed schemes.  Listing~\ref{scheme-scheme} shows the schemes installed by
default in the scripting environment {\tt stsh}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=scheme-scheme,caption=List of schemes via scheme:scheme.]
> scheme:scheme 
scheme-resolver with the following schemes: (defaults,  env, class,
    file, ftp,  http, https   default, var, sel,    scheme,    bundle,  mainbundle   )
\end{lstlisting}
\end{figure}

To illustrate the concepts, we will now present a few built-in scheme-handlers, ways to construct new
scheme-handlers out of existing scheme-handlers and apply these scheme-handlers to common
problems.

\subsection{Primitive Schemes}
\label{primitiveSchemes}

Primitive schemes are endpoints, they directly
mediate access to a specific kind of resource, often using a separate
library such as {\tt libwww} or {\tt libcurl}.  Primitive schemes
subsume both what is normally considered variable access and 
what is usually considered I/O, network and filesystem access.


\subsubsection{External resources}
\label{externalResources}

The list of default scheme-handlers in Listing~\ref{scheme-scheme} contains a few familiar URI schemes:
{\tt http}, {\tt https}, {\tt ftp}, and {\tt file}.   These behave in the expected way:   referencing them in an expression will
retrieve the bytes from the web-server, FTP-server or file, and placing them on the left hand side of
an assignment statement will perform an HTTP or FTP PUT request or write to a file system. 
 
Listing~\ref{download-to-file} shows how an RFC can be downloaded directly from a web-site
to a file, or how the web page could be updated given the right permissions, and demonstrates how integrating both filesystem access and the web as first class datatypes
goes some way to closing the gap between application programming languages and so called
scripting languages.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=download-to-file,caption=Downloading an RFC to a file.]
file:rfc1738:=http://datatracker.ietf.org/doc/rfc1738.
http://datatracker.ietf.org/doc/rfc1738:='New RFC'.
\end{lstlisting}
\end{figure}

In fact,  Objective-Smalltalk is used as a Unix scripting language using the {\tt stsh} command
interpreter for interactive and batch use with only minor adaptations to this use-case such
as semi-automatic parameter and return-value adaptation.


The {\tt stcat} script in Listing~\ref{stcat} prints an arbitrary resource to Unix standard output, 
similar to the way the Unix {\tt cat} command is used to display files\footnote{{\tt stcat} only 
displays a single resource rather than concatenating several.}.
The declaration of the {\tt stcat} script as a method in line 2 serves four purposes:  first, command-line
parameters are documented and second they can be coerced to the proper type and bound to
a script variable by the infrastructure rather than each script having to do its own parsing.   Third,
the script can be integrated into a larger program as an actual method that is invoked by sending
a message, rather than having to shell out to a separate process, converting arguments to strings
and parsing any return values via a pipe, and finally simply return values can just be returned from
the script and are automatically converted to a string and printed to stdout. 
Any command-line arguments not used by declared parameters
are bound to the {\tt args} array as strings.

In this particular case, the script is declared as taking the {\tt ref} argument {\tt file}
A {\tt ref} parameter is a Polymorphic Identifier that is partially evaluated to the reference stage,
but without retrieving the value.  Retrieving the value of the {\tt file} parameter is done in line 3,
and the result is automatically output to {\tt stdout} by {\tt stsh} because the declaration in line
2 indicates (by default) that {\tt stcat} has a return value.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=stcat,caption={\tt stcat} prints contents of any resource.]
#!/usr/local/bin/stsh
#-stcat:<ref>file
file value.
\end{lstlisting}
\end{figure}

The command  {\tt stcat http://datatracker.ietf.org/doc/rfc1738} shows RFC 1738 from the web site of the rfc-editor, whereas 
the command {\tt stcat file:\~\//.bashrc} will display the user's bash startup script, assuming you are a user of the
bash shell, and on a Unix system, {\tt stcat env:HOME} will print the path to 
your home directory.


With a current Unix shell all three of these resource types would have required a different
access syntax:   {\tt curl http://datatracker.ietf.org/doc/rfc1738} for the
web resource, {\tt cat  \~\//.bashrc} for the file and {\tt echo \$HOME} for the environment
variable, as would using Objective-Smalltalk without Polymorphic Identifiers .



The {\tt scurl} command in Listing~\ref{scurl} is slightly more complicated than {\tt stcat} because
it needs to manipulate the identifier.  The {\tt scurl} command
is the {\tt stsh} variant of the {\tt curl -O} command for downloading files from the web, giving 
{\tt scurl} the argument {\tt http://http://datatracker.ietf.org/doc/rfc1738} will download the specified web resource
to the current directory as the file {\tt rfc1738}.


\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=scurl,caption={\tt scurl} downloads files.]
#!/usr/local/bin/stsh
#-<void>scurl:<ref>urlref
fileName:= urlref identifier lastPathComponent.
file:{fileName} := urlref value.
\end{lstlisting}
\end{figure}

Line 2 declares
the script as a method named {\tt scurl} with the single argument {\tt urlref} and no return
value.  The {\tt urlref} parameter is declared as a {\tt ref}, meaning the string passed will
be interpreted as a Polymorphic Identifier that is evaluated to its reference but not further.
We then retrieve the last component of the Polymorphic Identifier into the {\tt fileName}
variable and finally retrieve the value of the {\tt urlref} and store it into the file that
the {\tt fileName} variable indicates.

The {\tt scurl} command does not only work on web references, but just as well
on files, so typing the command {\tt scurl \~\//.bashrc} will copy your bash resource from your home directory
to the local directory.

Access to metadata for a resource, such as availability, size or descendant nodes
is accomplished via the reference, which can support both common and scheme-specific
messages.

\subsubsection{In-memory resources}
\label{inmemory}

Although adding file and web references as integrated, first class objects to a programming
language is useful, it solves only parts of the problems from Section~\ref{identifiers}.
In addition, we also wish to integrate classical variable and attribute access.

In-memory stores such as the local execution context (often the stack), object instance
variables, thread-local and global heap variables are also managed by scheme-handlers
and made available using Polymorphic Identifiers.  Listing~\ref{local-variables} shows
several examples, {\tt ivar:} for instance variable access, {\tt local:} for the current
method context (``stack''), and {\tt thread:} for thread local variables.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=local-variables,caption=Different memory variables.]
local:tempAnswer := ivar:myAnswer.
thread:deepThought/privateAnswer := local:tempAnswer.
\end{lstlisting}
\end{figure}

These schemes allow path-based access
that is mediated by the objects in question.   Each object / class is asked at least
once for access to an attribute and then returns a reference.   This reference can
use message sending, keyed access or even a direct offset for very fast
access without requiring a JIT compiler.

There is also a {\tt global:} scheme for globals and a {\tt class:} scheme that separates
the namespace for instances from that for classes.  Having separate schemes for
these different storage classes is useful when wanting to disambiguate,
but can become cumbersome in itself.  To alleviate this, the composite
{\tt var:} scheme combines these schemes into a single namespace
with prioritized lookup similar to conventional languages.  We will take
a close look at composite schemes in the next section.  

The {\tt var} scheme is also usually bound as the resolver for the {\tt default}
scheme, which is assigned to identifiers that do not specify their scheme.
Combining the sequential lookup of the {\tt var:} scheme and the {\tt default}
scheme allows us to implement the usually hard-coded identifier lookup
rules for plain identifiers in Smalltalk and other languages using
our toolbox of scheme-handlers.

In addition to the schemes that recreate existing variable lookup, a number
of other useful scheme-handlers have been implemented so far.  We've
already seen the {\tt env:} scheme, which provides access to Unix
environment variables.  

A further scheme-handler that is not pre-loaded but available for defining
custom schemes is the {\tt SiteMap}.  A {\tt SiteMap} stores arbitrary objects
in memory in a tree structure that acts a bit like a memory filesystem.

\subsection{Composite Schemes}
\label{compositeSchemes}
Composite schemes  create a new scheme by combining one or 
more existing schemes. 

 Schemes used in programming 
are frequently composites of various primitive schemes, for example
the {\tt http} scheme will typically not actually be the raw http access
scheme provider, but a composite like the one in Figure~\ref{fig:http-cached} combining
raw http access with two caches, a file cache and an in-memory cache.


\begin{figure}[htbp]
\centering
\includegraphics[scale=0.4,page=1]{cached-http.pdf}
\caption{Typical http scheme-handler with caching, composed from simpler schemes}
\label{fig:http-cached}

\end{figure}


\subsubsection{Filter schemes}
\label{filterschemes}
Filter schemes take a single source scheme and apply processing to either
the identifiers passed to the source,  the data read from or written to the source, or both.

An example of a filter that just modifiers the identifier is the \emph{relative}
scheme, which as the name implies interprets identifiers relative to a base
identifier in its source scheme, for example a specific directory in the
filesystem.  

The caching http resolver in Figure~\ref{fig:http-cached} uses an instance
of a relative scheme to store its disk cache in a specific directory, rather
than at the root of the filesystem.  Another common use for relative schemes
is to provide an abstract name space that is then mapped to one
or more  concrete implementations, Listing~\ref{rfc-scheme} shows
an {\tt rfc:} scheme that is implemented by looking at the {\tt datatracker.ietf.org}
website.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=rfc-scheme,caption=Defining a custom rfc: scheme.]
scheme:rfc:=RelativeScheme schemeWithBase: ref:http://datatracker.ietf.org/doc
\end{lstlisting}
\end{figure}

Once the {\tt rfc} scheme from Listing~\ref{rfc-scheme} is defined, client code can 
retrieve a specific RFC using the identifier {\tt  rfc:rfc2396}.  Having abstracted
from the actual store for client code, we can now easily change it, for example
substituting a different server, a directory in a local filesystem or even an 
in-memory store.  Relative schemes are common enough that they can be
created by sending {\tt asScheme} to a reference: {\tt ref:http://datatracker.ietf.org/doc asScheme}.


%\begin{figure}[htbp]
%\begin{lstlisting}[style=L,label=rfc-scheme-convenience,caption=Defining a custom rfc: scheme.]
%scheme:rfc:=ref:http://datatracker.ietf.org/doc/ asScheme.
%\end{lstlisting}
%\end{figure}

%Since relative schemes are very common and usually based on a reference, the
%{\tt asScheme} convenience operation on references creates a relative scheme, as shown
%for the {\tt rfc:} scheme in Listing~\ref{rfc-scheme-convenience}.

A filter scheme that modifies data while leaving the URI as-is is the \emph{MIME-Type mapper}.
The mapper is parametrized with routines that create objects from data with specific
mime-types.  


\subsubsection{N-ary Schemes}

Composite schemes can have two or more source schemes and scheme-specific logic
to determine which of the source schemes to use for reading and writing data.

A very simple \emph{binary scheme} just performs sequential lookup:  try to
retrieve the value from the first source scheme, and if that fails try the second.
The {\tt var:} scheme from Section~\ref{inmemory}  replicates variable/identifier
lookup rules using a simple combination of sequential lookup schemes parametrized
with the underlying storage schemes.

By adding a write-back capability to the sequential lookup scheme, where an element
retrieved from the second source gets written to the first source, we get a simple \emph{cache} scheme.  
The caching http scheme we saw earlier in Figure~\ref{fig:http-cached} uses
separate cache scheme-handlers, one with an in-memory cache (the {\tt SiteMap} from Section~\ref{inmemory})
and the other with a file cache that consists of a relative scheme (section~\ref{filterschemes}) 
designating a specific directory in the filesystem.

The code to implement this composed, caching http scheme is similar 
to the diagram depicted in Figure~\ref{fig:http-cached}.  It is shown in Listing~\ref{http-composed-listing}:  
starting with the URL resolver (1) and the {\tt /tmp} directory for our cache (2), we construct
a file cache (3) an in-memory cache (4) and then hook up all these pieces together
in sequence using the {\tt ->} connector (5).

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=http-composed-listing,caption=Code for caching http stack.]
rawhttp := URLSchemeResolver scheme.
tempdir := ref:file:/tmp/ asScheme.
filecache := CacheScheme cacheWithScheme: tempdir.
memcache := CacheScheme memoryCache.
scheme:http := rawhttp -> filecache -> memcache.
\end{lstlisting}
\end{figure}

If we want our {\tt http:} scheme to retrieve domain objects, we instantiate a MIME-mapper
({\tt mapper := MIMEMapper defaultMapper}) and add it to the end of the chain of schemes: 
{\tt rawhttp->filecache->memcache->mapper}.  Alternatively, we can choose to cache the
domain objects instead using the following: {\tt rawhttp->filecache->mapper->memcache}.
Both variants are shown in Figure~\ref{http-cached-converted}.


\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5,page=1]{mapped-and-cached-http.pdf}
\caption{Two ways of adding conversion to the caching http-stack}
\label{http-cached-converted}
\end{figure}


With the MIME-mapper in place in the revamped http-scheme, we can now 
write the flickr.com example from Listing~\ref{nsurl-flickr-draw} inline as {\tt context drawImage:http:///{\ldots}jpg},
but using a user-defined {\tt flickr:} scheme, we can be even more concise:  
{\tt context drawImage: flickr:3559417932\_7208103ed8\_m.jpg}


\section{First-class references}
\label{references}

As we saw in Section~\ref{identifiers}, references are necessary for various programming tasks,
and many different mechanism exist to create them.   With the reification of the identifier lookup
process, we automatically get a reference object for every kind of resource access, but this
reference is hidden inside the Polymorphic Identifier system, because dereferencing the
reference is automatic.

The {\tt ref:} special scheme prevents evaluation of references and thus allows access
to the references themselves.  Listing~\ref{ref-binding} shows how basic access to
the value of a variable works via the reference.


\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=ref-binding,caption=Retrieve and store value via its reference.]
ref:theAnswer value.     //  returns 42
ref:theAnswer setValue:42.  
\end{lstlisting}
\end{figure}

Having exposed references as first class objects, we can now use them for parametrized 
access.  The GUI widget example from Section~\ref{identifiers} now
also takes just one argument in the widget (figure~\ref{ui-widget-reference}) just like
the ValueHolder version (figure~\ref{ui-widget-valueholder}).

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.51,page=1]{ui-widget-reference.pdf}
\caption{Widget using first-class reference}
\label{ui-widget-reference}

\end{figure}

However, we can have this convenience without the drawbacks of a parallel class
hierarchy, as we reuse the basic identifier lookup mechanism, and without any
inconvenience in creation, because we can just use the same syntax as we would
with a direct reference, only having to prefix a {\tt ref:} at the beginning:  {\tt ref:var:deepThought/theAnswer}.


\subsection{Common behavior for references}
\label{common-reference-behavior}
Apart from retrieving and storing values, references are also used to query and manipulate
metadata.  For example {\tt ref:env:bozo isBound} returns {\tt true} if the environment
variable {\tt bozo} exists and {\tt false} if it does not.

References also support a generic API for tree-based structures.   Apart from being used
by the runtime to support path-based access, these APIs are also used to export arbitrary
schemes as a user-level filesystem using FUSE or as a web-server using libmicrohttp.
Listing~\ref{fileserver} shows a server that exports a directory via http.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=fileserver,caption=Exporting a directory via http.]
#!/usr/local/bin/stsh
#-<void>fileserver:<ref>dir
context loadFramework:'MPWSideWeb'
server := dir -> (Cache memoryCache)  ->  (MPWSchemeHttpServer serverOnPort:8081)
server start:nil.
\end{lstlisting}
\end{figure}



\subsection{Scheme-specific behavior for references}

References are scheme-specific and can include additional API specific to that type of scheme.
For example, file bindings are analogues of the Java {\bf File} object and can deliver
meta-data about and perform operations such as querying whether a file is a directory, with
{\tt ref:file:/tmp/ isDirectory}.


Having the concept of references also regularizes some special-purpose APIs.  For example,
we can copy a file using the code {\tt file:a := file:b}.  If a {\tt ref:file:} is a reference to a file, what
happens when we write this reference to a file?  A symbolic link is created\footnote{A hard link
would be a reference to the inode, which isn't exposed by the kernel}.

References for remote resources include methods for initiating a transfer,
error-checking and progress monitoring.  

\subsection{Messaging mediated by references}

References also mediate message sends.   Messages are not sent directly to their objects, but via a
\emph{Higher Order Message} (HOM)~\cite{HOM}, in this case {\tt send}, to the receiver.    HOMs
are messages that take other messages as their argument, so the argument of the {\tt send} HOM is the
message that is to be sent to the value of the reference.  

  Line 1 of Listing~\ref{message-via-ref} shows
what happens when sending the {\tt setTheAnswer:} message to the {\tt deepThought} object with
the argument {\tt 42}.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=message-via-ref,caption=Message sending via reference and with syntactic sugar]
ref:deepThought send setTheAnswer:ref:newAnswer
deepThought setTheAnswer:newAnswer
\end{lstlisting}
\end{figure}

As with obtaining values from references, line 1 is consistent but would be too inconvenient for day to day use,
so line 2 shows the syntactic sugar version that is converted by the compiler to what's in line 1.  The {\tt send}
HOM implements the simple synchronous message send that is default Smalltalk semantics.   Arguments
are passed as references to the HOM, which can then decide whether to evaluate them.  The default {\tt send}
HOM evaluates all references to implement \emph{pass by value} semantics.

References can and do implement other message passing semantics, such as asynchronous sends, future
sends or remote message sending.  As such, they take over the role of \emph{Proxies}~\cite{VanCutsemMiller} for mediating non-default
message sending semantics.  


HOM is also used to construct URL arguments, as shown in Listing~\ref{url-args}.  The {\tt withArgs:}
HOM takes its message argument, in this case {\tt doi:'10.1.1.41.7628'} and converts into URL arguments,
in this case {\tt ?doi=10.1.1.41.7628}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=url-args,caption=URL arguments via reference and higher order message.]
  viewCiteSeer:=ref:http://citeseerx.ist.psu.edu/viewdoc/summary.
  (viewCiteSeer withArgs doi:'10.1.1.41.7628') value
\end{lstlisting}
\end{figure}


\subsection{Assignment via references}

Assignment is one of the few special operations in Smalltalk, like identifier de-reference it cannot be overridden.
The reason for the special nature of assignment is actually closely related to the monomorphic behavior
of identifiers:  normal lookup rules for identifiers implicitly means evaluation proceeds to the value, but in order to implement the left
hand side of an assignment, in order to actually bind a new value to an identifier, we need to stop evaluation
at the reference, so the left hand side is at a different meta-level than the right hand side\cite{kay-assignment}.

With first-class references, evaluation is always via the reference, so assignment is just a plain, though unsugared
message send that has references as both its receiver and argument.  The references then interact to resolve
the assignment, and can implement special behavior such as creating a symbolic link for a file-references assigned
to a file.

With assignment being a complex operation, we must now deal with the possibility of failure.  Assignments 
return a result that indicates status.  This status can also report progress for assignments that are
non-atomic, such as a file-copy or web-download.



\subsection{Kinds of references}
\label{refkinds}
In theory, every scheme can be accompanied by a specific kind of reference.  In practice, we have 
seen most references fall in one of three different categories:

\begin{enumerate}
\item Indexed references, where the reference is an offset into some sort of context, for
	example a stack frame or object.
\item Messaging references, where the reference corresponds to a set of messages to
	access the value.
\item Generic references, where the original identifier is preserved and/or converted to
	a string that is used as a parameter to a third party API, for example file names,
	web URLs or environment variable names.
\end{enumerate}

Another distinction we've seen is that some references are context-sensitive, while some
appear to be absolute references not requiring context.  The evaluation mechanism always
provides a context, which is ignored by some references.  


\section{Parametrized identifiers}
\label{parametrized}

One of the problems we repeatedly encountered in Section~\ref{identifiers} was 
that of specialized and parametrized access, which has been partly solved with
relative schemes and first class references.  Another common use case involves
mixing static and dynamic parts in a single identifier, which has to resolved by
using string processing.

Parametrized identifiers are identifiers that have parts that are evaluated
at runtime.  Curly brackets \{\} denote a section of the path that should be evaluated and
the return value used as part of the access path.

The example from Listing~\ref{rfcs-directory}, taking four lines of code to retrieve a specific RFC from a 
the {\tt rfcs} directory in the user's home directory can be expressed as the simple expression
{\tt file:\{env:HOME\}/rfcs/\{rfcName\}} using parametrized polymorphic identifiers.  It is almost
as concise as the Unix shell equivalent: {\tt \$HOME/rfcs/\$rfcName}, and can itself be packaged
in a file-based {\tt rfc:} scheme. 

This {\tt rfc:} scheme for a local directory can easily be extended with a sequential lookup scheme
and the {\tt rfc:} scheme from Section~\ref{filterschemes} to provide a multi-level lookup mechanism
for RFCs like the one described in 

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%


\section{Implementation Aspects}
\label{implementation}

As discussed earlier \emph{Polymorphic Identifiers} have been implemented as part of Objective-Smalltalk,
a Smalltalk dialect built on top of the Objective-C\cite{objc-evol}\cite{objc-apple} runtime, 
in a way that is similar to FScript\cite{fscript} and MacRuby \cite{macruby} in that Objective-Smalltalk classes,
objects and messages are essentially indistinguishable from their Objective-C counterparts.

Adding Polymorphic Identifiers to Objective-Smalltalk meant modifying the parser to allow URIs as identifiers
and allowing scheme-handlers to emit code for reference resolution and data access, which often
delegates this to run-time.

Scheme-handlers are often simple enough that we can include an almost complete scheme-handler below.

\subsection{A simple example scheme}

Listings~\ref{get-env}-\ref{hasValue-env} show the implementation of a simple scheme,
the env-scheme that provides access to Unix environment variables.  This scheme is
one that uses generic references (see Section~\ref{refkinds}), so the scheme is used
not only for generating references, but the references also call back into the scheme
to resolve themselves.

Listing~\ref{get-env} 
shows the {\bf bindingForName:inContext:} method that is the main access point for
converting from an identifier to a binding.  In this case, a generic binding object is returned
that simply stores the name of the identifier and lets the scheme that created it resolve
access via the {\bf valueForBinding:} and {\bf setValue:forBinding:} methods.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=get-env,caption=Basic lookup in env: scheme.]
-(const char*)cstringValueOfBinding:aBinding
{
  return getenv([[aBinding name] UTF8String]);
}

-bindingForName:aName inContext:aContext
{
  return [GenericBinding bindingWithName:aName scheme:self];
}

-valueForBinding:aBinding
{
  const char *val=[self cstringValueOfBinding:aBinding];
  if ( val ) {
    return [NSString stringWithUTF8String:val];
  } else {
    return nil;
  }
}
\end{lstlisting}
\end{figure}

In this case, the name of the identifier is simply passed to the POSIX {\bf getenv()} function.
Setting the value is handled in an analog fashion using the {\bf setenv()} function.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=setvalue-env,caption=Set value in env: scheme.]
-(void)setValue:val forBinding:binding
{
  val=[newValue stringValue];
  if ( val  ) {
    setenv([[binding name] UTF8String], [value UTF8String],1);
  } else {
    unsetenv([[binding name] UTF8String]);
  }
}
\end{lstlisting}
\end{figure}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=hasValue-env,caption=Checking for presence of value in env: scheme.]
-(BOOL)isBoundBinding:aBinding {
  return  [self cstringValueOfBinding:aBinding] != NULL;
}
\end{lstlisting}
\end{figure}



%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Evaluation}
\label{evaluation}

While Polymorphic Identifiers are still very much in the experimental stage, our
results so far are very encouraging.  What started out as just a hunch, that making
identifiers pluggable rather than relying on just messaging or a level of indirection
via strings might prove interesting, has been more than confirmed, and has proven
very productive.

While some effects were anticipated, others, such as the ability to solve the
``assignment problem'' or the discovery of a composition mechanism for
scheme-handlers proved serendipitous.  Subjectively, programming with Polymorphic
Identifiers seems natural and code appears to gain conciseness (as the examples
have shown) while more clearly expressing intent.

\subsection{Abstraction and Encapsulation}

The ability to define application specific storage namespaces via schemes such as {\tt rfc:} or {\tt flickr:}
allows developers to abstract from the particular storage mechanism used, and the syntactic
and semantic compatibility of scheme-handlers allows clients to flexibly choose specific storage
mechanisms and vary them at a later time, code is not bound to a particular storage mechanism.

Integrating this flexible storage mechanism with the language reduces boilerplate and hiding
the lookup methods eliminates the chances for interoperability-inhibiting naming differences in those lookup methods.



\subsection{Performance}

Like plain identifiers and messages, Polymorphic Identifiers benefit from having the compiler perform
at least the character to reference conversion step of identifier lookup, yielding performance 
improvements over string-based identifiers.

Figure~\ref{var-speed} compares evaluating the identifier {\tt var:stream/target/target} with evaluating the  
equivalent string-based identifier (using Cocoa KVC): {\tt [stream valueForKeyPath:@"target.target"]}.

We use the underlying Objective-C implementation for both the reference and its 
comparison because Objective-Smalltalk is currently an interpreted environment with
a simple AST-walker, so interpretation overhead makes performance differences in
the underlying lookup disappear.  Tests were run on a 2012 MacBook Pro 13" with 2.9 GHz Core i7 processor, the
code was self-timing using the {\tt getrusage()} call.  

\mpw{need more details here}


\begin{figure}
  \centering
\begin{minipage}[c]{0.38\textwidth}
\begin{tabular}{|r|r|r|r|r|r|r|r|r|r|r|r|} \hline
Accesses  & KVC& {\tt var:}   & ratio	\\ 
 & ($\mu$s) & ($\mu$s) & \\ \hline
1 & 14 & 10 & 1.4   \\ % \hline
10 & 22 & 10 &   2.2 \\   % \hline
100 & 100 & 14 &  7.0\\   % \hline
1000 & 1227 & 29 &  42.3  \\  % \hline
10000 & 8345 & 186 &   44.9 \\   % \hline
100000 & 73036 & 1730 &    42.2 \\ \hline
\end{tabular}
\end{minipage}
\begin{minipage}[c]{0.38\textwidth}
\includegraphics[scale=0.5,page=2]{kvc-vs-var.pdf}
\end{minipage}
\caption{Time for  {\tt var:} scheme vs. \emph{Key Value Coding} for two-element path access, log scale}
\label{var-speed}
\end{figure}

For large number of operations, access via the {\tt var:} scheme (or more precisely its reference) is
around 40 times faster than using Key Value Coding, confirming our expectations about the benefits
of partial compile-time evaluation versus string-interpretation at run-time.  

In order to test the overhead of scheme-handlers, especially composite scheme-handlers, we turn
to the ability to bridge scheme-handlers to servers briefly mentioned in Section~\ref{common-reference-behavior}.
We exported three different schemes via http and then used the {\tt wrk} http-performance testing tool to stress
test the resulting http servers, using apache as a benchmark to validate our results.  Tests were run on a 2012 MacBook Pro 13" with 2.9 GHz Core i7 processor.

Figure~\ref{http-server-speed} shows the results.  Serving a specific directory using a relative scheme parametrized
with the file scheme resulted in a performance level of around 19K requests per second.  Adding the same memory cache
we used for the caching http client scheme improves performance to 23K requests per second and finally exporting a pure
memory scheme yields the best performance at 31K requests per second.   Apache has many more features and so
has slightly lower performance.

\begin{figure}
\begin{minipage}[c]{0.58\textwidth}
\begin{tabular}{|l|c|c|} \hline
Server   &  Requests/s    \\ \hline
apache & 	14876	      \\ % \hline
home-scheme (file+relative) &  19231   \\ % \hline
home-scheme (+cached)  &  23398  \\ % \hline
memory-scheme (only) &  31491  \\ \hline
\end{tabular}
\end{minipage}
\begin{minipage}[c]{0.58\textwidth}
\includegraphics[scale=0.38,page=2]{server-perf.pdf}
\end{minipage}
\caption{Performance of different schemes bridged to http vs. apache}
\label{http-server-speed}
\end{figure}



%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%


\section{Related Work}
\label{related-work}


We already saw in Section~\ref{direct-reference} that messaging can be used for resource
access in lieu of plain identifiers.  Self~\cite{UngarS87} and Newspeak~\cite{Bracha:2010:MON:1883978.1884007} take this
approach to its logical conclusion by making all identifiers message-sends and therefore late-bound, eliminating
all nouns and replacing them with verbs\footnote{Literals are the exception}.  Although
this elimination of variables as a simplification is conceptually elegant, it leads to practical problems of scattering and tangling of code we
mentioned, and  ``left a complexity that bothers us to this day''~\cite{Ungar:2007:SEL:1238844.1238853}.
Handling the assignment part of resource access leads to ad-hoc rules and mechanisms to tie together
the slot accessor methods that Ungar and Smith say ``troubled us a bit''~\cite{Ungar:2007:SEL:1238844.1238853}.

Polymorphic Identifiers are a result of the same basic premise that identifiers should always be late-bound.  However,
it doesn't follow the apparent implicit assumption that only messaging can be late-bound and therefore identifiers must
be messages in order to be late-bound, and the related assumption that interfaces must be message-based.

This assumption certainly doesn't apply to the World Wide Web and the REST architectural style~\cite{fielding-rest}, where
it is (universal) resource identifiers that are the interfaces, and messaging is the hidden implementation detail.  This 
approach is taken to its logical extreme by  by Resource Oriented Computing \cite{roc},
which encodes all computation into identifiers, with an {\tt action:} scheme that is ``a functional programming language encoded as a URI''.

Although scheme-handlers can be exported via http, Polymorphic Identifiers leave the decision of whether to present a messaging
or a resource-based interface to the developers,
similar to properties in C\#~\cite{Archer:2001:IC:516715} and Objective-C 2.0~\cite{Kochan:2009:PO:1538451}, which closely match the proposal in \cite{Spinellis:2002:MPC:510857.510868}.  Properties are syntactic sugar for a pair of accessor methods and allow clients to use 
 plain identifiers syntax to access values via message-sends, including assignment for setting the value.   However, properties
 are just syntactic sugar for one type of resource access, they are not user-extensible like Polymorphic Identifiers 
 and don't integrate access to external resources or first class references.


The E language~\cite{MillerRobustComposition}  supports URI-Expressions as a direct language feature using angle brackets for access to 
resources such as files using and to the underlying Java classes:   {\tt $\langle$file:/home/marcs/myFile.txt$\rangle$},  {\tt $\langle$unsafe:java.util.makeCalendar>.getYEAR()$\rangle$}.
E even allows custom schemes to be defined, but  only for read-access, separate from other identifiers and without the ability to extract references.

The Icon programming language \cite{IconRef} has references as first class values, but these are not extensible and have complex,
built-in rules for whether they are evaluated or treated as references, rather than having explicit control as with Polymorphic Identifiers.

A different approach to resource access comes from the operating system community:  Plan9 
integrates a wide variety of local and remote~\cite{plan9network} resources and services into a single directory tree~\cite{plan9names} that is made available on a per-process basis.
User level filesystems like FUSE\cite{fuse} or the BSD Pass-to-User-Space\cite{kantee:puffs} 
system bring some of these ideas to commercial operating systems, but must have access mediated via the kernel and visible global to all
processes on a machines. 

Polymorphic Identifiers also allow different local and remote resource handlers to be combined via
scheme-handlers, but are a programming language concept and thus integrated with their general purpose
programming language.  Plan9 servers on the other hand are operating system constructs managed by the
kernel and accessed from C using standard I/O system calls.  These system calls use string-based identifiers
to open communications channels and write and read commands and results respectively via I/O calls.

\mpw{currently working in this area}

\emph{Polymorphic Identifiers} are similar to Embedded Domain Specific Languages\cite{edsl}
in that they allow domain-specific language elements to be added to a language, rather
than having to create a completely new language with an external DSL or attempt to 
achieve the desired effect with an internal DSL\cite{fowlerdsl}.  

Like polymorphic embedding of DSLs \cite{polydsl}, \emph{Polymorphic Identifiers} allow
a single syntax to be used with multiple, pluggable semantic interpretations permitting
composition of functionality\cite{embeddeddsl}.  However, \emph{Polymorphic Identifiers}
are applicable to general purpose programming languages, not just DSLs, while
at the same time restricting their focus to the identifiers used.




%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Summary and Outlook}
\label{summary-and-outlook}

We have introduced \emph{Polymorphic Identifiers}, a reified and user extensible 
generalization of plain identifiers, and shown how they
solve the problem of polymorphic resource access without
the code duplication and brittleness of a pure message-oriented approach or the
numerous problems of the workaround that is using string-based identifiers.

\emph{Polymorphic Identifiers} allow the substitution of alternate implementations,
as well as the introduction of 
application-specific schemes that are completely custom.
Custom scheme-handlers can be implemented as normal objects and added
to the language, or even composed from pre-existing handlers and
combinators.

With the user-extensible identifier architecture of Polymorphic Identifiers, it becomes possible to add abstraction
and information-hiding capabilities to identifiers and expand the use of REST-style
programming beyond network and Web-environments.

\section*{Acknowledgements}

We would like to thank Gilad Bracha, Carl Friedrich Bolz, Richard Gabriel, and Michael Perscheid for their
helpful feedback.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

%\appendix
%\section{Appendix A}

%This is the text of the appendix, if you need one.

%\acks

%Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\vfill
\break

\bibliographystyle{abbrv}
\bibliography{polymorphic-identifiers}


% The bibliography should be embedded for final submission.

%\balancecolumns

\end{document}
