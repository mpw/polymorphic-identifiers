%-----------------------------------------------------------------------------
%
%    Domain Specific Identifiers
%
%-----------------------------------------------------------------------------


\documentclass[preprint,authoryear]{acm_proc_article-sp}

\usepackage{ifthen}

\usepackage{amsmath}
\usepackage{epigraph}
\usepackage[colorlinks=true,
        linkcolor=blue,
        citecolor=red,
        filecolor=black,
        pagecolor=black,
        urlcolor=black,
        bookmarks=true,
        bookmarksopen=true,
        bookmarksopenlevel=3,
        plainpages=false,
        pdfpagelabels=true]{hyperref}

%%--- listings configuration
\usepackage{listings}
\lstset{
  language={C},
  basicstyle=\ttfamily,
  keywordstyle=\bfseries,
  showstringspaces=false,
  commentstyle=,
  captionpos=below%,
%  numbers=left,
%  numberstyle=\tiny,
%  numbersep=5pt
}
%\lstdefinestyle{L}{basicstyle=\ttfamily}
\lstdefinestyle{L}{basicstyle=\ttfamily\scriptsize}
\lstdefinestyle{numbers}
{numbers=left, stepnumber=1, numberstyle=\tiny, numbersep=10pt,basicstyle=\ttfamily\scriptsize}

%%--- end of listings configuration



\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
  {\newcommand{\mynote}[2]{
      {\color{red}
    \fbox{\bfseries\sffamily\scriptsize#1}
       {\small$\blacktriangleright$\textsf{\emph{#2}}$\blacktriangleleft$}
    % \marginpar{\fbox{\bfseries\sffamily#1}}
        }
   }
   \newcommand{\cvsversion}{\emph{\scriptsize $ $Revision: 1.42 $ $ -- $ $Date: 2005/10/01 00:23:32 $ $ }}
  }
  {\newcommand{\mynote}[2]{}
   \newcommand{\cvsversion}{}
  }

\newcommand{\here}{\mynote{***}{CONTINUE HERE}}
\newcommand\nb[1]{\mynote{NB}{#1}}
\newcommand\fix[1]{\mynote{FIX}{#1}}
% \newcommand\todo[1]{\mynote{TO DO}{#1}}
\newcommand\mpw[1]{\mynote{Marcel}{#1}}
\newcommand\rh[1]{\mynote{Robert}{#1}}


\begin{document}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2011} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.


\title{Polymorphic Identifiers}
%\subtitle{Subtitle Text, if any}

\numberofauthors{2}
\author{
\alignauthor Marcel Weiher\\
       \affaddr{metaobject ltd.}\\
       \email{marcel@metaobject.com}
\alignauthor Robert Hirschfeld\\
       \affaddr{Hasso Plattner Institut}\\
       \email{}
}

\maketitle

\begin{abstract}

In object oriented programming, direct value (resource) access is generally discouraged or 
even made impossible, being replaced with access mediated via messaging in order to
gain the benefits of mediated access, encapsulation and polymorphism.

However, neither messaging itself nor resource access mechanisms built strictly on top
of messaging achieve these goals, instead causing code duplication, tying varying 
implementations to specific interfaces, causing brittleness in the face of changes as well
as performance problems and making parametrized access difficult.

We propose {\em polymorphic identifiers} as a reified and open replacement for both
language- and user-provided identifier mechanism. 


\end{abstract}

\category{D.3.3}{Programming Languages}{Language Constructs and Features}

\terms{language, design}
\keywords{polymorphic identifiers} % NOT required for Proceedings
\setlength{\epigraphrule}{0pt}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Introduction}

We report on an experimental
technique for expanding our ability to directly name and reference many different 
resources
in programming languages using a common identifier and identifier resolution
mechanism.
These \emph{polymorphic identifiers} are not only user-extensible,
but can also be manipulated in the programming language, making them first class 
entities.

Our starting point is Smalltalk, where we have objects
that communicate via messages\cite{Goldberg1983}, although we use the Apple's Cocoa
class library\cite{Cocoa}.  Identifiers are used to identify 
objects, but are early bound by the compiler.  Late-binding of names, encapsulation,
and polymorphic behavior can only be achieved via message-sends.


Identifiers that need to point to other entities or be used in different ways must be defined
by the programmer and cannot be used interchangeably with built in identifiers.  

The contributions of this paper are
\begin{enumerate} \item a uniform, composable and extensible resource access mechanism for all
resources in a program, \item  a way of integrating that access mechanism naturally into the language for
direct, {\em identifier oblivious} access and
\item a uniform treatment of references for indirect, {\em identifier aware} access.
\end{enumerate}

In section~\ref{identifiers}, we will look at different ways of accessing resources and see
the shortcomings of those approaches.  In section~\ref{polymorphic-identifiers}, we 
describe {\em polymorphic identifiers} as a reification, abstraction and extension of existing 
identifier lookup mechanisms.  Section~\ref{schemes} gives more details on {\em scheme resolvers},
an important component especially for composability, whereas section~\ref{references} looks
at references, which mediate access.  



%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%





\section{Identifiers}
\label{identifiers}
%\epigraph{When programming a component, the right computation model for the component is the least expressive model that results in a natural program.}{Rule of Least Expressiveness.}


Identifiers that name resources come in many different forms ranging from local,
global or instance variables to names for disk files or URIs pointing to network resources.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.55,page=1]{basic-storage.pdf}
\caption{Generic identifier lookup}
\label{identifier-eval}
\end{center}
\end{figure}

Whatever the specific type, the relationship between the actual identifier and the
final value looks like figure~\ref{identifier-eval}, with slight variations:   there is
the identifier itself, which is a human-readable character string, there is some sort
of store that has identifiable slots or cells and there is a value stored in one of those
cells.   In order to retrieve a value, the identifier is converted to a value using the
hypothetical {\em ref(identifier)} function and then the reference is used to look up an actual
value from a slot using the {\em value(reference)} function.


We will look at 4 distinct types of identifiers that all follow this basic pattern:  language-supported 
{\em direct reference}, where identifiers directly resolve to values, {\em message-based} lookup
used for encapsulation,
{\em string-based} lookup often used with extensible data structures or filesystem access and
finally reified object access.   While each of these approaches solves a part of the problem,
none of them is satisfactory in the end, either lacking capability and extensibility or leading to
irreducible code-duplication, brittleness and simply cumbersome code.

\subsection{Plain identifiers}
\label{direct-reference}
Like most programming languages, our dialect of Smalltalk, called
{\em Objective-Smalltalk} allows you to just write 
an identifier by itself, and this will not just reference the slot that the identifier names, but also
automatically retrieve the value stored in that slot.  Storing into the slot is accomplished with
the assignment operator {\tt :=}.    Assuming I have a variable that contains {\tt theAnswer} to 
life, the universe and everything, I can access it as shown in listing~\ref{variable-lookup}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=variable-lookup,caption=Interacting with a local resource.]
  theAnswer.
  theAnswer := 42.
\end{lstlisting}
\end{figure}

Due to the fact that the programmer does not, and cannot, deal with either the identifier
or the reference, but names the value using the identifier, we call this an {\em identifier oblivious}
access.  This type of direct access is only possible for a few specific variable types
(local, instance, class, pool and global) and supported directly by the compiler.

If it were possible to make the lookup explicit, what we call {\em identifier aware},
the code would look something like listing~\ref{reified-variable-lookup}.  Apart
from the infinite recursion ({\tt thisContext}  also needs to be looked up),
forcing this style would be prohibitive from both effort/readability and performance
perspectives.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=reified-variable-lookup,caption=Reified local resource access.]
  (thisContext slotAtName:'theAnswer') get.
  (thisContext slotAtName:'theAnswer') set:42.
\end{lstlisting}
\end{figure}

Whereas using this type of direct access with non-local objects is considered at least
questionable style in languages that support it, such as Java or C++, it is simply prohibited in Smalltalk.
The reason is that syntactically direct access is conflated with machine-level direct
access:  the implementation is a straight memory reference, without any possibility
of providing alternative storage strategies or intervening programmatically.

Languages with pointers such as C++ and Objective-C can provide a reference to a variable
by taking the address using the {\tt \&} operator ({\tt \&theAnswer}).   However, this is once
again a direct memory reference without any encapsulation or options of providing 
alternate implementations in the future.  Smalltalk once again prohibits such access.

\subsection{Messages as identifiers}

Encapsulation and the potential for polymorphic behavior can be achieved by using
messages to access the value in question.  Listing~\ref{variable-lookup} shows 
obtaining or setting {\tt theAnswer} by interacting with the {\tt deepThought}\cite{adams1997hitchhiker} object,
as shown in listing~\ref{message-access}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=message-access,caption=Asking an object.]
  deepThought getTheAnswer.
  deepThought setTheAnswer:42.
\end{lstlisting}
\end{figure}

Due to the fact that resource access is hidden behind a message send that will cause
a method to execute, the client does not know wether {\tt deepThought} will just
quickly return a stored representation or instead go off to compute the answer for 
several hundred million years. 

While this level of encapsulation, with its potential for polymorphic behavior, is 
beneficial, it does come at a cost:   instead of the factored 
representation of an identifier and two verbs, {\tt get} and {\tt set},
this is multiplied out for each and every visible attribute of 
each and every class. 
 
This entanglement means we  
must provide two trivial accessor methods like the ones in listing~\ref{trivial-accessors} for each actual resource we wish
to access.  Studies show that around 5\% of Java code consists of such trivial accessors\cite{Spinellis:2002:MPC:510857.510868}, and although the authors of said study argue that this is {\em not} enough
to warrant special treatment, it should be noted that the prevalence of actual polymorphic 
message sends is also reported to be around 5\% \cite{Holzle:1991:ODO:646149.679193}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=trivial-accessors,caption=Trivial accessors.]
getTheAnswer
    ^theAnswer.

setTheAnswer:newAnswer
    theAnswer := newAnswer.

\end{lstlisting}
\end{figure}

As we should expect, all that unfactored code gets us into trouble if we want 
to make changes:   if we want to globally change how the {\tt set}
operation works, for example, either because we want a different storage
mechanism or some additional behavior,
we must manually change the trivial accessor for every attribute to which
we want to apply this change.


As long as we can compute messages to send at runtime,
passing references to message-accessed resources is easier than with
direct references.  However, not having a factored representation also means
duplication at call sites, because 
access to the resource has been split into two distinct messages whose only relationship is by 
convention.   Figure~\ref{ui-widget-msg-access} shows the example of a text field
that interacts generically interact with a string attribute of an object, in 
this case the {\tt theAnswer} attribute of a {\tt DeepThought} object.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.51,page=1]{ui-widget-generic-access-messages.pdf}
\caption{Widget using messages for parametrized access}
\label{ui-widget-msg-access}
\end{center}
\end{figure}

In order to handle this reference to an attribute, we need to store the base object,
the getter and the setter messages, and also provide all these elements when
initializing the object.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=parametrized-message-access,caption=Parametrized access via messages.]
self base performSelector:self setter 
	       withObject:self getContents.
self setContent:(self base performSelector:self getter)
\end{lstlisting}
\end{figure}

Apart from the problems with duplications, using messages as the interface for resource
access also poses difficulties with multi-element access paths.  These need to be decomposed
into multiple distinct message sends, and references such as the widget in figure~\ref{ui-widget-msg-access}
would need to be extended to arrays of message selectors.

\subsection{Strings as identifiers}

Another alternative to plain identifiers are identifiers based on strings, which are one 
way to write human-readable names in program text that is completely opaque to the language itself.
They can be used as an interface to message-based access that tries to mitigate some of the problems
identified, for user-defined custom storage
mechanisms and to interact with external resources such as files or web-sites.


One of many examples of string-based identifiers is Cocoa's {\em Key Value Coding} (KVC)\cite{KVC} protocol,
which uses string keys to provide
an easier to use interface for parametrized message-based access.  
KVC adds two methods to every object, {\tt valueForKey:} and {\tt setValue:forKey:},
with the key parameter being the string that's used as an identifier.  These generic access methods 
use string processing on the key to determine the appropriate getter or setter message and 
then use the message to actually store or retrieve the value.  

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=kvc-literal-string,caption=Strings used with {\em Key Value Coding} (KVC).]
deepThought valueForKey:'theAnswer'.
deepThought setValue:42 forKey:theAnswer.
\end{lstlisting}
\end{figure}

Listing~\ref{kvc-literal-string} shows how this gets close to the factored ideal of having a single identifier,
in this case the string {\tt theAnswer} and two generic access methods, in this case the two KVC methods.
However, listing~\ref{kvc-literal-string} also shows the cost:  significant syntactic noise as the identifier
lookup mechanism is turned from something that works automatically behind the scenes (see figure~\ref{identifier-eval}
and listing~\ref{variable-lookup}) to something that has to be specified by the developer at every step (see 
listing~\ref{reified-variable-lookup} ).   Having to expose the lookup mechanism like this adds brittleness and
runtime overhead, as well as preventing the compiler from helping with even basic consistency checks.


Figure~\ref{ui-widget-string-access} and listing~\ref{kvc-variable-string} show how KVC simplifies parametrized access for 
the client:  instead of having to specify two messages, the getter and the setter, a single string key can be used with
the two generic accessors.  The actual access mechanism is a little more complicated, but this is hidden and can 
be reused.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.51,page=1]{ui-widget-generic-access-string.pdf}
\caption{Widget using string identifiers for parametrized access}
\label{ui-widget-string-access}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=kvc-variable-string,caption=Parametrized access via KVC.]
self base setObject:self getContents forKey:self key.
self setContent:(self base objectForKey:self key).
\end{lstlisting}
\end{figure}

Custom stores are also typically accessed via string keys, as shown in listing~\ref{string-identifiers-custom} for
a plain dictionary and a persistent store of user preferences.  Although string keys can also be considered 
identifiers, both because that is the role they have and because the way they are used is identical to
the string identifier usage above, they cannot be used interchangeably because of the incompatibility
introduced by the exposed lookup method, in one case {\tt valueForKey:} and on the other case {\tt objectForKey:}.
The identifiers by themselves are actually not uniquely determined, they require their lookup method to also
be specified.


We could ameliorate the situation slightly by having a single universal protocol
for string-identifier lookup, but that makes the actual message essentially
meaningless and thus even more syntactic noise, and also means that we need
to somehow differentiate the lookup scope within the string identifier.   The
{\em schemes} used in URIs to differentiate lookup scopes are a potential
solution.


\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=string-identifiers-custom,caption=String-based identifiers for custom storage.]
aDictionary objectForKey:'theAnswer'.
aDictionary setObject:42 forKey:'theAnswer'.
NSDefaults standardUserDefaults
	 objectForKey:'theAnswer'.
NSDefaults standardUserDefaults
	 setObject:'42' forKey:'theAnswer'.
\end{lstlisting}
\end{figure}


File access also uses string-based identifiers, starting with the Unix system calls ({\tt open()}) and the standard I/O library ({\tt fopen()}).
Object oriented languages and toolkits follow this tradition, with a couple of examples shown in listing~\ref{string-file-identifiers}.
The use of string identifiers introduces the context problem we saw above, hard-wiring client code to file-system access,
rather than having a pluggable store.   However, making access pluggable would require at least a 2 step process at the
call-site, making client code much less convenient.  

This context problem is multiplied by the number of available access methods, leading to potentially quadratic growth in
required methods:
the {\tt imageNamed:} method provides a specialized cached access method for named images, but this generically useful
capability is not made available to other classes because it has to be tied to a specific class.  Retrieving an object from
a web-site requires yet another method per class(e.g. {\tt NSData dataWithContentsOfURL:} and {\tt NSString stringWithContentsOfURL:}).



\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=string-file-identifiers,caption=Files of different types accessed using string identifiers.]
NSData dataWithContentsOfFile:'theAnswer.txt'
NSString stringWithContentsOfFile:'theAnswer.txt'
'42' writeToFile:'theAnswer.txt' atomically:YES.
UIImage imageWithContentsOfFile:'answerImage.png'.
UIImage imageNamed:'pictureOf42'.
\end{lstlisting}
\end{figure}

Another problem is that paths frequently have to be composed from a combination of system-provided base paths
and fixed as well as variable components, for example a specific RFC stored in the {\tt rfcs} directory in the user's
home directory ({\tt \$HOME/rfcs/\$rfcName}).  Because strings are basically a flat und semantically minimal data structure, clients
must perform sometimes extensive string process as that shown in listing~\ref{rfcs-directory} to actually access
data, use format strings or have special syntax such as the shell path above.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=rfcs-directory,caption=Accessing a specific RFC in a directory relative to the user's \$HOME.]
home := NSProcessInfo processInfo 
          environment objectForKey:'HOME'.
rfcDir  := home stringByAppendingPathComponent:'rfcs'.
rfcPath := rfcDir stringByAppendingPathComponent:rfcName.
rfcText := NSString stringWithContentsOfFile:rfcPath.
\end{lstlisting}
\end{figure}




\subsection{Reified identifiers}


Unlike strings, reified references can be semantically rich and self-contained, not requiring
a separate evaluator, und unlike
messages they can encapsulate both read and write access in one entity.  VisualWorks 
Smalltalk uses {\em ValueHolder} objects to handle the parametrized access we've been
looking at, while Cocoa uses the {\tt NSURL} class to represent references that are URLs.

Figure~\ref{ui-widget-valueholder} shows how a ValueHolder reduces the entities the widget
needs to interact with to one, from three in the case of message-based identifiers and two
in the case of string-based identifiers.  As it should be, how the ValueHolder accesses 
its underlying data is completely hidden from clients, so different containers or access
strategies can be substituted without having to modify client code.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.51,page=1]{ui-widget-valueholder.pdf}
\caption{Widget using ValueHolder for parametrized access}
\label{ui-widget-valueholder}
\end{center}
\end{figure}

Similarly, {\tt NSURL} at least ameliorates the context problems for strings used as
references to external resources, due to the fact that URL syntax can specify 
various access paths using {\em schemes} and these are handled via a plug-in 
architecture. 

However, what {\em ValueHolders} and {\tt NSURL}s gain in encapsulation and flexibility,
they lose in convenience and expressiveness:   since reified identifiers have no literal
syntax that is equivalent to a name, they must first be initialized with a name, typically
a string, as shown in listing~\ref{reified-identifiers}, then the URL must be loaded and
finally the data retrieved converted into an object, which can then be used, for example
for drawing.  For local variables, the code 
would resemble the counter-example given in listing~\ref{reified-variable-lookup}.


\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=reified-identifiers,caption=Drawing an image stored on flickr.]
answerURL := NSURL URLWithString:
	'http://www.depthought.com/theAnswer'.
NSData dataWithContentsOfURL:answerURL.
\end{lstlisting}
\end{figure}

The problems of relative identifiers discussed in the previous section also apply, for example requiring
string processing before creating the URL as shown in listing~\ref{rfc-web-string-processing}.  


\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=rfc-web-string-processing,caption=Retrieving a specific RFC (I).]
base:='http://datatracker.ietf.org/doc/'.
rfcLocation := base stringByAppendingPathComponent:rfcName.
rfcUrl := NSURL URLWithString:rfcLocation.
rfcText := NSData dataWithContentsOfURL:rfcUrl.
\end{lstlisting}
\end{figure}

 Listing~\ref{nsurl-flickr-draw}
shows the complete process for drawing an image with a specific ID from flickr on a graphics context,
whereas drawing the same image with the same ID stored within the application's bundle
is shown in listing~\ref{flickr-local-draw}.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=nsurl-flickr-draw,caption=Retrieving and drawing a remote image.]
flickrURL :=NSURL URLWithString:
	'http://static.flickr.com/2438/'.
imageURL := NSURL 
         URLWithString:'3559417932_7208103ed8_m.jpg' 
         relativeToURL:flickrBase.
imageData := NSData dataWithContentsOfURL:imageURL.
image := UIImage imageWithData:imageData.
context drawImage: image.
\end{lstlisting}
\end{figure}

Not only is the amount of code vastly different, but the two versions are also very different.  Due to the inconvenience
of the regular API, web services tend to provide site-specific APIs that are incompatible from site to site and 
incompatible with other types of resource access.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=flickr-local-draw,caption=Retrieving and drawing a local image.]
context drawImage: (UIImage imageWithName:
	'3559417932_7208103ed8_m').
\end{lstlisting}
\end{figure}

A final problem, apart from the loss of directness and expressiveness, is that we have now pretty
much exactly duplicated the identifier lookup mechanism that's built into the language (see figure~\ref{identifier-eval}
in user space.  Such code duplication should be avoided, but we are prevented from applying refactoring
to implement on in terms of the other by the fact that one is hard-wired into the language and the other is not.

\subsection{Discussion}

Although resource access is one of the most basic operations in a programming, combining it
with traits we have come to expect from object-orientation such as encapsulation, polymorphic
behavior and user-extensibility turns out to be surprisingly difficult.   All the potential names
we have available (plain identifiers, message names and strings) fall short:  direct references
using plain identifiers don't' have the features we would like, messages incur code bloat
and brittleness, string identifiers suffer from indirectness, runtime evaluation and more
code bloat, and reifying also does not help.

A solution would need to combine the expressiveness of direct references and the universality
of polymorphic message sends with the extensibility and flexibility of string-based identifiers.


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Polymorphic Identifiers}
\label{polymorphic-identifiers}
%\epigraph{A change in perspective is worth 80 IQ points}{Alan Kay}

The irreducible code duplication and frequent need to embed (mini-)languages into the
source code as strings we saw in section~\ref{identifiers} suggests that the issue needs to be
solved at the linguistic level.

Instead of using messaging or strings to get polymorphic resource access, polymorphic identifiers
generalize direct references,  just like messaging generalized function calls and made them polymorphic.
Polymorphic identifiers combine the techniques for resource access discussed in the previous 
section by:
\begin{enumerate}
\item extending the syntax for identifiers to that of Universal Resource Identifiers (URIs)\cite{rfc3986},
\item reifying the identifier lookup process and
\item making it user-extensible with open-implementation techniques.
\end{enumerate}

Listing~\ref{polymorphic-identifier-examples} recasts the examples from section~\ref{identifiers} using
polymorphic identifiers.  Lines 1-4 are just direct references corresponding to section~\ref{direct-reference},
the {\tt var} scheme is the default so lines 1 and 3 are equivalent, as are 2 and 4.
Lines 5-6 shows access to an object's attribute, which corresponds to section~\ref{message-access} and is
mediated by the object, using message sends or other means at the object's discretion.  Whether messaging
is used to implement the access is encapsulated as an implementation detail.  Lines 7-14 correspond
to the string-reference examples in listing~\ref{string-identifiers}, with for example line 12 storing the
value {\tt 42} in the file {\tt theAnswer.text}.   Line 15 corresponds to the retrieval of a URL resource in listing~\ref{reified-identifiers}, while line 16 uses the {\tt ref} scheme to inhibit full evaluation, therefore just returning the
URL reference rather than actually retrieving the value (References will be discussed more fully in section~\ref{references}).

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=polymorphic-identifier-examples,caption=Some variants of polymorphic identifiers.]
theAnswer.
theAnswer:=42.
var:theAnswer.
var:theAnswer:=42.
var:deepThought/theAnswer.
var:deepThought/theAnswer := 42.
var:aDictionary/theAnswer.
var:aDictionary/theAnswer := 42.
defaults:theAnswer.
defaults:theAnswer := 42.
file:theAnswer.txt.
file:theAnswer.txt := 42.
file:answerImage.png.
img:pictureOf42.
http://www.depthought.com/theAnswer.
ref:http://www.depthought.com/theAnswer.
\end{lstlisting}
\end{figure}

The very regular structure of the identifiers in listing~\ref{polymorphic-identifier-examples} strongly
suggests interoperability, and this is in fact the case:  scheme names are not fixed but can be
assigned at will, making it possible to substitute schemes.

The polymorphic identifier system consists of three basic parts:
\begin{enumerate}
\item {\em Polymorphic Identifiers} themselves are URIs.  They are typically created by the 
	compiler and have a structured runtime representation that can be manipulated
	at a semantic level rather than as character strings, so consistency can be 
	maintained.
\item {\em Scheme handlers} manage a set of resources and, when registered,
	 the namespace that is associated
	with them.  They primarily turn {\em polymorphic identifiers} into {\em references} and
	are created by developers, with a basic set provided by the environment.
\item {\em References} are created and used transparently by the runtime and compiler
	to mediate access to the specific resource identified by a {\em polymorphic identifier}.
	
	
\end{enumerate}

All three elements are plain objects that only become part of the language when registered
with the compiler or runtime.

Figure~\ref{scheme-eval} shows the generic identifier lookup of figure~\ref{identifier-eval}
extended to polymorphic identifiers.  The basic mechanism is still the same except for the
addition of {\em scheme handlers} mediating the lookup process.  The left hand side of the
diagram corresponds to the lookup in figure~\ref{identifier-eval}, with the difference that
the lookup that was previously hardwired into the language is now mediated by the {\tt var}
scheme handler, which in turn was selected by the {\tt var} scheme that's part of the 
polymorphic identifier.


\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.45,page=1]{scheme-evaluation.pdf}
\caption{Polymorphic Identifier lookup}
\label{scheme-eval}
\end{center}
\end{figure}


The right hand side of figure~\ref{scheme-eval} shows fetching of a web-resource from
a remote server following the same four step lookup process, with the steps labeled by
number:

\begin{enumerate}
\item a character sequence is turned into  polymorphic identifier,
\item the scheme part of the polymorphic handler is used to select a scheme handler, in this case the {\tt http} handler,
\item the scheme handler evaluates the {\em scheme-specific} part of the polymorphic identifier ({\tt //deepThought.org/theAnswer})
	 and returns a reference, in this case a web-reference,
\item this (web-)reference mediates access to the actual resource, in this case translating requests to store or retrieve the 
	resource into HTTP GET or PUT requests via an http client library.
\end{enumerate}

These four steps can happen at compile- or run-time and can be partially completed.
A reference to a local stack variable, for example, will typically have none of the
three components visible at run time, with all that remains being optimized 
machine code to directly access the resource (the stack variable).
A file or web-reference, on the other hand, will typically have the PI itself
compiled, with evaluation deferred until runtime.  Finally, there are facilities
for turning strings into PIs at runtime.


\section{Schemes and scheme handlers}
\label{schemes}
The addition of {\em schemes} to identifiers in order to distinguish different kinds of resources
and resource access, rather than having to revert to function calls or messages, represents
the major addition that {\em polymorphic identifiers} bring to a programming language.
Each scheme is backed by a {\em scheme handler}, which broadly fall into two categories:
 {\em primitive schemes} (section~\ref{primitiveSchemes})
directly encapsulate access to some sort of resource, while {\em composite schemes} (section~\ref{compositeSchemes})
can be used to build new schemes out of existing schemes, forming a little scheme algebra.


Scheme handlers are normal objects that respond to a well-defined protocol that can be
accessed by user level code.  They
become part of the language by binding them to particular scheme, after which
any {\em polymorphic identifiers} with that scheme will be resolved by that particular scheme handler.
Listing~\ref{scheme-scheme-http} shows how an {\tt URLSchemeResolver} instance is bound
to the {\tt http} scheme and a {\tt FileSchemeResolver} bound to the {\tt file} scheme.  The table 
binding schemes to resolvers is itself a scheme, the {\em scheme scheme}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=scheme-scheme-http,caption=Binding scheme handlers to the http and file schemes.]
  scheme:http := URLSchemeResolver scheme.
  scheme:file := FileSchemeResolver scheme.
\end{lstlisting}
\end{figure}

It is both possible and common to bind other handlers to those scheme
names, for example an {\bf http} handler that implements a multi-level caching scheme
or a {\bf file} scheme served from memory for testing purposes.  Any scheme-handler
can be used for any scheme-name, as long as it implements the handler protocol
compatibly.

Note that perfect interoperability is not guaranteed or required, so there is no notion
of transparent remote access, for example.  Different scheme handlers will have different supported
data types, different access modalities and different levels of quality of service.
Polymorphic identifiers only remove accidental, mostly syntactic, incompatibility for accessing different types
of resources when those resources are semantically compatible within the parameters
of the requesting application.


The {\em scheme scheme} can also be queried,
so the expression {\bf scheme:http} returns the currently installed http handler, and 
{\bf scheme:scheme} returns the scheme scheme itself, which will list the currently
installed schemes.  Listing~\ref{scheme-scheme} shows the schemes installed by
default in the scripting environment {\tt stsh}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=scheme-scheme,caption=List of schemes via scheme:scheme.]
> scheme:scheme 
scheme-resolver with the following schemes: (
    file, ftp,  http, https
    default, var, sel,    scheme,
    bundle,  mainbundle,
    defaults,  env,
    class,
)
\end{lstlisting}
\end{figure}

To illustrate the concepts, we will now present a few common scheme handlers and how they can be
used to solve common problems.  While no one scheme handler is required, at least conceptually,
the scheme handlers we present will try to demonstrate what sorts of schemes can be created,
how they can be combined into a usable system and finally used to solve problems.

\subsection{Primitive Schemes}
\label{primitiveSchemes}

Primitive schemes are the endpoints for resource access, they directly
mediate access to a specific kind of resource, often using a separate
library such as {\tt libwww} or {\tt libcurl}.  Primitive schemes
subsume both what is normally considered variable access and 
what is usually considered I/O, network and filesystem access.


\subsubsection{External resources}
\label{externalResources}

The list of default scheme-handlers in listing~\ref{scheme-scheme} contains a few familiar URI schemes:
{\tt http} and {\tt https}, {\tt ftp}, {\tt file}.   These behave in the expected way:   referencing them in an expression will
retrieve the bytes from the web-server, FTP-server or file, and placing them on the left hand side of
an assignment statement will perform an HTTP or FTP PUT request or write to a file system. 
 
Listing~\ref{download-to-file} shows how an RFC can be downloaded directly from a web-site
to a file, or how the web page could be updated given the right permissions, and demonstrates how integrating both filesystem access and the web as first class datatypes
goes some way to closing the gap between application programming languages and so called
scripting languages.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=download-to-file,caption=Downloading an RFC to a file.]
file:rfc1738:=http://datatracker.ietf.org/doc/rfc1738.
http://datatracker.ietf.org/doc/rfc1738:='New RFC'.
\end{lstlisting}
\end{figure}

In fact,  Objective-Smalltalk is used as a Unix scripting language using the {\tt stsh} command
interpreter for interactive and batch use.  

The {\tt stcat} script in listing~\ref{stcat} prints an arbitrary resource to standard out, 
similar to the way the Unix {\tt cat} command is used to display files\footnote{{\tt stcat} only 
displays a single resource rather than concatenating several.}.
After the ``hashbang'' in line 1 {\tt stcat} is declared as a method taking the {\tt ref} argument {\tt file} 
in line 2.
A {\tt ref} parameter is a polymorphic identifier that is partially evaluated to the reference stage,
but without retrieving the value.  Retrieving the value of the {\tt file} parameter is done in line 3,
and the result is automatically output to {\tt stdout} by {\tt stsh} because the declaration in line
2 indicates (by default) that {\tt stcat} has a return value.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=stcat,caption={\tt stcat} prints contents of any resource.]
#!/usr/local/bin/stsh
#-stcat:<ref>file
file value.
\end{lstlisting}
\end{figure}

To load RFC 1738 from the rfc-editor web site, type  {\tt stcat http://datatracker.ietf.org/doc/rfc1738}, whereas 
the command {\tt stcat \~\//.bashrc} will display your bash startup script, assuming you are a user of the
bash shell, and on a Unix system, {\tt stcat env:HOME} will print the path to 
your home directory.

With a current Unix shell all three of these resource types would have required a different
command or access syntax:   {\tt curl http://datatracker.ietf.org/doc/rfc1738} for the
web resource, {\tt cat  \~\//.bashrc} for the file and {\tt echo \$HOME} for the environment
variable, as would using Objective-Smalltalk without polymorphic identifiers .

The {\tt scurl} command in listing~\ref{scurl} is slightly more complicated than {\tt stcat} because
it needs to manipulate the identifier.  The {\tt scurl} command
is the {\tt stsh} variant of the {\tt curl -O} command for downloading files from the web, typing
{\tt scurl http://http://datatracker.ietf.org/doc/rfc1738} will download the specified web resource
to the current directory as the file {\tt rfc1738}.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=scurl,caption={\tt scurl} downloads files.]
#!/usr/local/bin/stsh
#-<void>scurl:<ref>urlref
fileName:= urlref identifier lastPathComponent.
file:{fileName} := urlref value.
\end{lstlisting}
\end{figure}

After the ``hash-bang'' specifying the command interpreter in the first line, line 2 declares
the script as a method name {\tt scurl} with the single argument {\tt urlref} and no return
value.  The {\tt urlref} parameter is declared as a {\tt ref}, meaning the string passed will
be interpreted as a polymorphic identifier that's evaluated to its reference but not further.
We then retrieve the last component of the polymorphic identifier into the {\tt fileName}
variable and finally retrieve the value of the {\tt urlref} and store it into the file that
the {\tt fileName} variable indicates.

Of course the {\tt scurl} command doesn't just work on web references, but just as well
on files, so typing the command {\tt scurl \~\//.bashrc} will copy your bash resource from your home directory
to the local directory.

Access to metadata for a resource, such as availability, size or descendant nodes
is accomplished via the reference, which can support both common and scheme-specific
messages.

\subsubsection{In-memory resources}
\label{inmemory}

Although adding file and web references as integrated, first class objects to a programming
language is useful, it solves only a small part of the problems from section~\ref{identifiers}.
In addition, we also wish to integrate classical variable and attribute access.

In-memory stores such as the local execution context (often the stack), object instance
variables, thread-local and global heap variables are also managed by scheme handlers
and made available using polymorphic identifiers.  Listing~\ref{local-variables} shows
a couple of examples, {\tt ivar:} for instance variable access, {\tt local:} for the current
method context (``stack''), and {\tt thread:} for thread local variables.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=local-variables,caption=Different memory variables.]
local:tempAnswer := ivar:myAnswer.
thread:deepThought/privateAnswer := local:tempAnswer.
\end{lstlisting}
\end{figure}

All these schemes have different starting points but then allow path-based access
that is mediated by the objects in question.   Each object / class is asked at least
once for access to an attribute and then returns a reference.   This reference can
use message sending, keyed access or even a direct offset for very fast
access without requiring a sophisticated JIT compiler.

There is also a {\tt global:} scheme for globals and a {\tt class:} scheme that separates
the namespace for instances from that for classes.  Having separate schemes for
these different storage classes is useful when wanting to disambiguate,
but can become cumbersome in itself.  To alleviate this, the composite
{\tt var:} scheme combines these schemes into a single namespace
with prioritized lookup similar to conventional languages.  We will take
a close look at composite schemes in the next section.  

The {\tt var} scheme is also usually bound as the resolver for the {\tt default}
scheme, which is assigned to identifiers that don't specify their scheme.
Combining the sequential lookup of the {\tt var:} scheme and the {\tt default}
scheme allows us to implement the usually hard-coded identifier lookup
rules for plain identifiers in Smalltalk and other languages using
our toolbox of scheme handlers.

In addition to the schemes that recreate existing variable lookup, a number
of other useful scheme handlers have been implemented so far.  We've
already seen the {\tt env:} scheme, which provides access to Unix
environment variables.  

A further scheme handler that is not pre-loaded but available for defining
custom schemes is the {\tt SiteMap}.  A {\tt SiteMap} stores arbitrary objects
in memory in a tree structure that acts a bit like a memory filesystem.

\subsection{Composite Schemes}
\label{compositeSchemes}
Composite schemes  create a new scheme by combining one or 
more existing schemes with some processing to create new behavior
or a new type of resource store. 

 Schemes used in programming 
are frequently composites of various primitive schemes, for example
the {\tt http} scheme will typically not actually be the raw http access
scheme provider, but a composite like the one in figure~\ref{fig:http-cached} combining
raw http access with two caches, a file cache and an in-memory cache.


\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.5,page=1]{cached-http.pdf}
\caption{Typical http scheme handler with caching, composed from simpler schemes}
\label{fig:http-cached}
\end{center}
\end{figure}


\subsubsection{Filter schemes}
\label{filterschemes}
Filter schemes take a single source scheme and apply processing to either
the identifiers passed to the source, or the data read from or written to the source.

An example of a filter that just modifiers the identifier is the {\em relative}
scheme, which as the name implies interprets identifiers relative to a base
identifier in its source scheme, so for example a specific directory in the
filesystem.  

The caching http resolver in figure~\ref{fig:http-cached} uses an instance
of a relative scheme to store its disk cache in a specific directory, rather
than the root of the filesystem.  Another common use for relative schemes
is to provide an abstract name space that is then mapped to one
or more  concrete implementations, listing~\ref{rfc-scheme} shows
an {\tt rfc:} scheme that is implemented by looking at the {\tt datatracker.ietf.org}
website.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=rfc-scheme,caption=Defining a custom rfc: scheme.]
  base := ref:http://datatracker.ietf.org/doc/.
  scheme:rfc := RelativeScheme schemeWithBase:base.
\end{lstlisting}
\end{figure}

Once the {\tt rfc} scheme from listing~\ref{rfc-scheme} is defined, client code can 
retrieve a specific RFC using the identifier {\tt  rfc:rfc2396}.  Having abstracted
from the actual store for client code, we can now easily change it, for example
substituting a different server, a directory in a local filesystem or even an 
in-memory store.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=rfc-scheme-convenience,caption=Defining a custom rfc: scheme.]
scheme:rfc:=ref:http://datatracker.ietf.org/doc/ asScheme.
\end{lstlisting}
\end{figure}

Since relative schemes are very common and usually based on a reference, the
{\tt asScheme} convenience operation on references creates a relative scheme, as shown
for the {\tt rfc:} scheme in listing~\ref{rfc-scheme-convenience}.

A filter scheme that modifies data while leaving URL alone is the {\em MIME-Type mapper}.
The mapper is parametrized with routines that create objects from data with specific
mime-types.  


\subsubsection{Binary Schemes}

Binary composite schemes have two source schemes and scheme-specific logic
to determine which of the source schemes to use for reading and writing data.

A very simple {\em binary scheme} just performs sequential lookup:  try to
retrieve the value from the first source scheme, and if that fails try the second.
The {\tt var:} scheme from section~\ref{inmemory}  replicates variable/identifier
lookup rules using a simple sequence of sequential lookup schemes parametrized
with the underlying storage schemes.

By adding a write-back capability to the sequential lookup scheme, where an element
retrieved from the second source gets written to the first source, we get a simple {\em cache} scheme.  
The caching http scheme we saw earlier in figure~\ref{fig:http-cached} uses two cache
separate cache schemes, one with an in-memory cache (the {\tt SiteMap} from section~\ref{inmemory})
and the other with a file cache that consists of a relative scheme (section~\ref{filterschemes}) 
designating a specific directory in the filesystem.

The code to implement this composed, caching http scheme is not all 
that different from the diagram.  It is shown in listing~\ref{http-composed-listing}:  
starting with the URL resolver (1) and the {\tt /tmp} directory for our cache (2), we construct
a file cache (3) an in-memory cache (4) and then hook up all these pieces together
in sequence using the {\tt ->} connector (5).

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=http-composed-listing,caption=Code for caching http stack.]
rawhttp := URLSchemeResolver scheme.
tempdir := ref:file:/tmp/ asScheme.
filecache := CacheScheme cacheWithScheme: tempdir.
memcache := CacheScheme memoryCache.
scheme:http := rawhttp -> filecache -> memcache.
\end{lstlisting}
\end{figure}

If we want our {\tt http:} scheme to retrieve domain objects, we simple add a MIME-mapper
to the end as shown in listing~\ref{http-cached-converted-listing} and figure~\ref{http-cached-converted}.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=http-cached-converted-listing,caption=Caching and converting.]
mapper := MIMEMapper defaultMapper.
scheme:http := rawhttp->filecache->memcache->mapper.
\end{lstlisting}
\end{figure}


\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.5,page=1]{cached-and-mapped-http.pdf}
\caption{Adding conversion to the caching http-stack}
\label{http-cached-converted}
\end{center}
\end{figure}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=http-converted-cached-listing,caption=Converting and caching.]
scheme:http := rawhttp->filecache->mapper->memcache .
\end{lstlisting}
\end{figure}


With the mime-type mapper in place, it might make more sense to
cache the deserialized representation in memory rather than
the raw bytes.  This change in caching strategy only requires
the minimal change in the configuration of the composed http-scheme
shown in figure~\ref{http-converted-cached} and listing ~\ref{http-converted-cached-listing}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.5,page=1]{mapped-and-cached-http.pdf}
\caption{Caching the converted object}
\label{http-converted-cached}
\end{center}
\end{figure}


With the mime-mapper in place in the revamped http-scheme, we can now use 
an image that's stored on a remote server just by writing out its URL, as shown
in listing~\ref{image-drawing}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=image-drawing,caption=Drawing a remote image via {\tt http:}.]
context drawImage: 
  http://static.flickr.com/2438/3559417932_7208103ed8_m.jpg
\end{lstlisting}
\end{figure}

We can also create a special {\tt flickr:} scheme from the base URL {\tt ref:http://static.flickr.com/2438},
so hiding static parts of the URL,
and then draw using just the (still long) image id (listing~\ref{flickr-scheme}).

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=flickr-scheme,caption=Drawing remote image via {\tt flickr:}]
context drawImage: flickr:3559417932_7208103ed8_m.jpg
\end{lstlisting}
\end{figure}


\section{First class references}
\label{references}


As we saw in section~\ref{polymorphic-identifiers} and figures~\ref{scheme-eval} and \ref{identifier-eval}, {\em references}
are usually used implicitly to access values and therefore hidden inside the PI system.  However,
as we saw in section~\ref{identifiers}, having references visible is sufficiently valuable that various
mechanisms have been created that parallel the built-in identifier lookup mechanism in order to
get visible references.

The reification of identifier lookup in the PI system means that identifiers are available as objects, 
they just need to be made visible.   Since references are evaluated to get values, the 
simplest way from an implementation point of view would be for identifiers to always just
evaluated to references and then have the client interact with the references to get to
the values, what we have called the {\em identifier aware} style of programming.

However, {\em identifier oblivious} access, where the identifier is assumed to mean the
value is sufficiently more common that it makes sense to have evaluation of not just
the identifier but also the reference be the default, and stopping the evaluation at the
reference be the special case.

The {\tt ref:} special scheme prevents evaluation of the reference and thus allows access
to the reference itself.  Listing~\ref{ref-binding} illustrates the syntax and semantics:
first a variable {\tt a} is defined and bound to a value 42 (1) using direct-reference syntax,
then we obtain a reference {\tt ref:b} to
the identifier for the first variable {\tt a} (3).  We can now manipulate variable {\tt a} 
in a generic way through the reference we have obtained in variable {\tt b} (5).  

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=ref-binding,caption=Accessing a variable via its reference.]
  a := 42.
  a.  //  displays 42.
  b := ref:var:a.
  b value  //  displays 42.
  b bindValue:2.
  a  //  displays 2
\end{lstlisting}
\end{figure}

Having exposed references as first class objects, we can now use them for parametrized 
access.   Using references, the GUI widget example from section~\ref{identifiers} now
also takes just one argument in the widget (figure~\ref{ui-widget-reference}) just like
the ValueHolder version (figure~\ref{ui-widget-valueholder}).

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.51,page=1]{ui-widget-reference.pdf}
\caption{Widget using first class reference}
\label{ui-widget-reference}
\end{center}
\end{figure}

However, we can have this convenience without the drawbacks of a parallel class
hierarchy, as we reuse the basic identifier lookup mechanism, and without any
inconvenience in creation, because we can just use the same syntax as we would
with a direct reference, only having to prefix a {\tt ref:} at the beginning:  {\tt ref:var:deepThought/theAnswer}.




Apart from retrieving and storing values, references are also used to query manipulate
metadata, for example wether a reference is bound to a value, which can mean that
a file or an environment variable exists.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=isBound,caption=Is environment variable set?]
ref:env:bozo isBound  // false
env:bozo := 'hi'
ref:env:bozo isBound  // true
\end{lstlisting}
\end{figure}

Reference are scheme-specific and can include additional API specific to that type of scheme.
For example, file bindings are analogues of the Java {\bf File} object and can deliver
meta-data about and perform operations on the file as shown in Listing~\ref{ref-file-dir}.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=ref-file-dir,caption=Is {\tt /tmp} a directory?]
ref:file:/tmp/ isDirectory  //  true, on Unix
\end{lstlisting}
\end{figure}

References for remote resources include methods for initiating a transfer,
error-checking and progress monitoring.  

\section{Evaluated identifiers}



\mpw{References and relative scheme not only}

One example is parametrization, with an identifier having parameters that are evaluated
at runtime.  Curly brackets \{\} denote a section of the path that should be evaluated and
the return value used as part of the access path.

Listing~\ref{rfc-local-ref} recasts the example in listing~\ref{}, retrieving a specific RFC from a 
the {\tt rfcs} directory in the user's home directory using polymorphic identifiers.  It is almost
as concise as the Unix shell equivalent {\tt \$HOME/rfcs/\$rfcName}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=rfc-local-ref,caption=Parametrized identifier for local RFC access.]
  file:{env:HOME}/rfcs/{rfcName}
\end{lstlisting}
\end{figure}

\mpw{here}


Different abstraction mechanisms can be combined, for example yielding
a scheme that represents file in the current user's home directory, shown
in Listing~\ref{home-scheme}.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=home-scheme,caption=Accessing .bashrc via custom home: scheme.]
  base := ref:file:{env:HOME}.
  scheme:home := RelScheme schemeWithBase:base.
  home:.bashrc.
\end{lstlisting}
\end{figure}

A sequential composition scheme simply searches a list of other schemes
for a particular identifier.  It searches its argument schemes sequentially
for the identifier in question and returns the first match.  Lookup rules for
identifiers that are usually hard-coded into languages can be expressed
as a sequential composition scheme, for example:   \{ scheme:local ,
scheme:ivar , scheme:classvar , scheme:poolvar , scheme:global \} for Smalltalk 
(ignoring the capitalization rules for now).

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%



\section{Implementation}
\label{implementation}

\emph{Polymorphic identifiers} have been implemented as part of Objective-Smalltalk \cite{objst},
a Smalltalk dialect built on top of the Objective-C\cite{objc-evol}\cite{objc-apple} runtime, 
in a way that is similar to FScript\cite{fscript} and MacRuby \cite{macruby}.

Objective-C is an ahead-of-time-compiled, hybrid, and dynamic object oriented programming language
that is an extension of C.  The object-oriented extensions to C are closely modeled on
Smalltalk, with dynamic single-dispatch at runtime, a keyword syntax and classes as
largely first-class objects.

Objective-Smalltalk objects and classes are Objective-C objects, they are created using
the same functions and data structures and are indistinguishable at runtime.
The same goes for Objective-Smalltalk methods, which are also indistinguishable from
Objective-C methods, making Objective-Smalltalk in a sense a meta-circular language
that is written in itself, or more precisely written in variants of itself \cite{kleinvm}\cite{squeak}.



\subsection{Example}

Listings~\ref{get-env}-\ref{hasValue-env} show the implementation of a simple scheme,
the env-scheme that provides access to Unix environment variables.  While this scheme
is actually string-based, that fact is hidden and the strings are not exposed to the user.
Listing~\ref{get-env}
shows the {\bf bindingForName:inContext:} method that is the main access point for
converting from an identifier to a binding.  In this case, a generic binding object is returned
that simply stores the name of the identifier and lets the scheme that created it resolve
access via the {\bf valueForBinding:} and {\bf setValue:forBinding:} methods.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=get-env,caption=Basic lookup in env: scheme.]
-(const char*)cstringValueOfBinding:aBinding
{
  return getenv([[aBinding name] UTF8String]);
}

-bindingForName:aName inContext:aContext
{
  return
    [GenericBinding bindingWithName:aName scheme:self];
}

-valueForBinding:aBinding
{
  const char *val=[self cstringValueOfBinding:aBinding];
  if ( val ) {
    return [NSString stringWithUTF8String:val];
  } else {
    return nil;
  }
}
\end{lstlisting}
\end{figure}

In this case, the name of the identifier is simply passed to the POSIX {\bf getenv()} function.
Setting the value is handled in an analog fashion using the {\bf setenv()} function.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=setvalue-env,caption=Set value in env: scheme.]
-(void)setValue:val forBinding:binding
{
  val=[newValue stringValue];
  if ( val  ) {
    setenv([[binding name] UTF8String],
      [value UTF8String],1);
  } else {
    unsetenv([[binding name] UTF8String]);
  }
}
\end{lstlisting}
\end{figure}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=hasValue-env,caption=Checking for presence of value in env: scheme.]
-(BOOL)isBoundBinding:aBinding
{
  return 
    [self cstringValueOfBinding:aBinding] != NULL;
}
\end{lstlisting}
\end{figure}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=url-args,caption=URL arguments via reference and higher order message.]
  host := 'citeseerx.ist.psu.edu'.
  viewCiteSeer:=ref:http://{host}/viewdoc/summary.
  viewCiteSeer getWithArgs doi:'10.1.1.41.7628'.
\end{lstlisting}
\end{figure}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Evaluation}
\label{evaluation}

\mpw{KVC vs. PI performance}

\mpw{concise without obfuscation}

\mpw{identifier manipulation better than just strings?}

\mpw{flickr with cache (because easy to create), vs. NSURL that caches before the image}

\mpw{cached web-server vs. Apache}


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%


\section{Related Work}
\label{related-work}

There has been a lot of work on extensible languages, but very little of that work 
has focused on identifiers.  

\subsection{Path-based access in languages}

Programming languages such as C, C++ or Pascal have facilities for composite
identifiers, for example using the dot or {\bf -> } operators in C, but these facilities allow
direct access to the internal data, without any ability of the structure in question to 
mediate.  The same thing goes for passing a pointer to a substructure:  while it
does give a single entity that can be used to access a sub-part of a structure, it
does so without any access controls.

Properties in C\# and Objective-C 2.0 allow a variable-access interface to be backed by 
message sending, thus allowing path-based access under dynamic control of the object
in question, but without having first-class references or the ability to access other
types of resources using a unified mechanism.

ThingLab\cite{thinglab}  adds path-based access to the base Smalltalk language in order to support
constraints referencing parts of objects, say the vertex of a triangle, and these
references do exist as first class objects that can be passed to other objects.
   It does not
expand this path-based access to other domains or make it user-extensible.

AppleScript\cite{applescript-hopl3} exposes a program's object model via
phrases that correspond to access path.  Listing~\ref{AppleScript} shows 
how to access the title of the currently playing iTunes track and set this
as the current iChat status message.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label= AppleScript,caption=Using AppleScript to set chat status from track name.]
  tell application "iTunes"
    set trackname to name of current track
  end tell
  tell application "iChat"
    set status message to trackname
  end tell
\end{lstlisting}
\end{figure}

With \emph{polymorphic identifiers}, the same operation can be expressed
much more concisely as a simple assignment between two URIs,
as shown in Listing~\ref{NonAppleScript}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=NonAppleScript,caption=Access to applications via \emph{polymorphic identifiers}.]
  app:iChat/statusMessage := app:iTunes/currentTrack/name.
\end{lstlisting}
\end{figure}


\subsection{Unified path-based access mechanisms}


User level filesystems like FUSE\cite{fuse} or the BSD Pass-to-User-Space\cite{puffs} 
system allow
user-level code to add new filesystems to the Unix kernel, without requiring
kernel modifications or impacting operating system kernel stability.

This approach allows many sorts of local and remote data-types to be 
treated as files in a filesystem and made available to the wide variety
of Unix tools that can navigate and process such files.  

However, this support requires global installation of handlers in the operating
system, which also must mediate access, making integration of in-memory 
variables difficult at best.  The identifiers used to access these resources
are also still strings that are not integrated with the identifier mechanism of
the host language, with all the problems discussed in Section~\ref{stringtrouble}.

Using FUSE/puffs filesystems as scheme resolvers without kernel intervention seems
like a useful addition, as is making scheme-resolvers available to the Unix kernel
via FUSE/puffs.

The Plan9\cite{plan9names}\cite{plan9network} operating system from Bell Labs goes further than FUSE in integrating
all data, local and network resources into a single hierarchical namespace.  Similar
caveats as for FUSE apply.

Phantom XML\cite{phantomxml} unifies access to data by treating all data as
XML trees, allowing queries against this XML representation of the data without
actually converting it to XML first.  




\subsection{URIs in E}

The E language\cite{MillerRobustComposition}  supports URI-Expressions as a
direct language feature.  Example include access to files
using file URI  {\bf <file:c:/jabbertest>} or Web-resources using HTTP {\bf <http://www.erights.org>}.  However,
E only supports using these URI expressions in the reference-aware style and does not integrate 
ordinary identifiers into the URI mechanism, provide abstraction facilities 
for URIs or an extension mechanism. 


\subsection{References in Icon}

In the Icon programming language \cite{IconRef} , identifiers (references) can be first class values,
and there are complex rules for when a reference remains a reference and when
it's value is used.  However, the rules are implicit and there is no way for the 
developer to choose when to be identifier-aware or identifier-oblivious.  Furthermore,
there is no way for the user to extend the language with new types of references 
or behaviors.



\subsection{Domain specific languages}

\emph{Polymorphic identifiers} are similar to Embedded Domain Specific Languages\cite{edsl}
in that they allow domain-specific language elements to be added to a language, rather
than having to create a completely new language with an external DSL or attempt to 
achieve the desired effect with an internal DSL\cite{fowlerdsl}.  

Like polymorphic embedding of DSLs \cite{polydsl}, \emph{polymorphic identifiers} allow
a single syntax to be used with multiple, pluggable semantic interpretations permitting
composition of functionality\cite{embeddeddsl}.  However, \emph{polymorphic identifiers}
are applicable to general purpose programming languages, not jus DSLs, while
at the same time restricting their focus to just the identifiers used.

\subsection{Proxies, mirrors, and mirages}

Smalltalk reflective facilities \cite{reflective-st} have long been used to build
facilities such as distributed object systems, futures, lazy evaluation and
transparent storage mechanisms.  One problem with the Smalltalk facilities
has been that they are defined in an ad-hoc fashion from error handling routines
and not sufficiently stratified, with meta-level functions
interfering with base-level functions and vice-versa.  Another problem is that
most reflective techniques only apply to messages, not to identifiers, making 
those techniques unavailable.

Mirrors \cite{mirrors} and Mirages \cite{mirages} improve the stratification and
reflection/intercession capabilities, but are not capable of dealing with pure
identifiers or of bringing user-defined resource handlers into the language.

The proposed ECMAScript Proxy mechanism \cite{VanCutsemMiller} addresses
the stratification issues and also integrates some identifier access into the 
metaprogramming framework, but doesn't allow user-extensible identifiers.

We believe that mechanisms such as remote objects, futures, proxies and the like
are actually properly modeled not at the object level, but at the identifier/reference
level, so that a significant part of what is currently considered metaprogramming
can be considered programming at the identifier level.

\subsection{Internet programming languages and systems}

The success of the REST architectural style\cite{fielding-rest} on the Web has sparked
systems and languages that try to more directly model and take advantage of that
style.

The Wheat language \cite{wheat} embedded an entire programming language
and system into a Web-server, accessing all resources and methods via
HTTP URLs.  \emph{Polymorphic identifiers} allow resources, but these resources
are not required to use a specific communications mechanism.


Resource Oriented Computing \cite{roc} goes even further by
requiring all computation to be expressed through URIs, adding Active URIs
for computation as shown in Listing~\ref{activeuri}.   


%\begin{figure}[htbp]
%\begin{center}
%\begin{small}
%\begin{verbatim}
%active:{base}+{name}@{uri}...
%\end{verbatim}
%\end{small}
%\caption{Active URI}
%\label{activeuri}
%\end{center}
%\end{figure}

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label= activeuri,caption=Active URI.]
  active:{base}+{name}@{uri}...
\end{lstlisting}
\end{figure}

The {\bf base} is a function name, the {\bf name} an argument name and the
{\bf uri} an argument URI.
 While \emph{polymorphic identifiers} allow processing to be
hidden behind a resource URI, they also allow messaging to be expressed
as messaging when that is the intent.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Summary and Outlook}
\label{summary-and-outlook}

We examined both built-in and user-defined identifiers in programming languages 
and separated their usage patterns into an {\em identifier-oblivious} style where
the identifier is used by itself to denote its bound value and the 
an {\bf identifier-aware} style where the identifier itself is used as a first class value
and its value can only be accessed indirectly.

While each style is appropriate in different usage-scenarios, current languages 
tie the usage style to wether the identifier is built-in or user-defined.  \emph{Polymorphic
identifiers} remove the distinction between user-defined and built-in identifiers by having
a single type of user-extensible identifier that can be used in both identifier-oblivious
and identifier-aware styles.

With a user-extensible identifier architecture, it becomes possible to add abstraction
and information-hiding capabilities to identifiers and expand the use of REST-style
programming beyond network and Web-environments.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

%\appendix
%\section{Appendix A}

%This is the text of the appendix, if you need one.

%\acks

%Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\vfill
\break

\bibliographystyle{abbrv}

% The bibliography should be embedded for final submission.
\bibliography{polymorphic-identifiers}

\balancecolumns
\end{document}
