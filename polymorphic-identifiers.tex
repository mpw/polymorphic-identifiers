%-----------------------------------------------------------------------------
%
%    Domain Specific Identifiers
%
%-----------------------------------------------------------------------------


\documentclass[preprint,authoryear]{acm_proc_article-sp}

\usepackage{ifthen}

\usepackage{amsmath}
\usepackage{epigraph}
\usepackage[colorlinks=true,
        linkcolor=blue,
        citecolor=red,
        filecolor=black,
        pagecolor=black,
        urlcolor=black,
        bookmarks=true,
        bookmarksopen=true,
        bookmarksopenlevel=3,
        plainpages=false,
        pdfpagelabels=true]{hyperref}

%%--- listings configuration
\usepackage{listings}
\lstset{
  language={C},
  basicstyle=\ttfamily,
  keywordstyle=\bfseries,
  showstringspaces=false,
  commentstyle=,
  captionpos=below%,
%  numbers=left,
%  numberstyle=\tiny,
%  numbersep=5pt
}
%\lstdefinestyle{L}{basicstyle=\ttfamily}
\lstdefinestyle{L}{basicstyle=\ttfamily\scriptsize}
\lstdefinestyle{numbers}
{numbers=left, stepnumber=1, numberstyle=\tiny, numbersep=10pt,basicstyle=\ttfamily\scriptsize}

%%--- end of listings configuration



\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
  {\newcommand{\mynote}[2]{
      {\color{red}
    \fbox{\bfseries\sffamily\scriptsize#1}
       {\small$\blacktriangleright$\textsf{\emph{#2}}$\blacktriangleleft$}
    % \marginpar{\fbox{\bfseries\sffamily#1}}
        }
   }
   \newcommand{\cvsversion}{\emph{\scriptsize $ $Revision: 1.42 $ $ -- $ $Date: 2005/10/01 00:23:32 $ $ }}
  }
  {\newcommand{\mynote}[2]{}
   \newcommand{\cvsversion}{}
  }

\newcommand{\here}{\mynote{***}{CONTINUE HERE}}
\newcommand\nb[1]{\mynote{NB}{#1}}
\newcommand\fix[1]{\mynote{FIX}{#1}}
% \newcommand\todo[1]{\mynote{TO DO}{#1}}
\newcommand\mpw[1]{\mynote{Marcel}{#1}}
\newcommand\rh[1]{\mynote{Robert}{#1}}


\begin{document}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2011} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.


\title{Polymorphic Identifiers}
%\subtitle{Subtitle Text, if any}

\numberofauthors{2}
\author{
\alignauthor Marcel Weiher\\
       \affaddr{metaobject ltd.}\\
       \email{marcel@metaobject.com}
\alignauthor Robert Hirschfeld\\
       \affaddr{Hasso Plattner Institut}\\
       \email{}
}

\maketitle

\begin{abstract}

In object oriented programming, direct value (resource) access is generally discouraged or 
even made impossible, being replaced with access mediated via messaging in order to
gain the benefits of mediated access, encapsulation and polymorphism.

However, neither messaging itself nor resource access mechanisms built strictly on top
of messaging achieve these goals, instead causing code duplication, tying varying 
implementations to specific interfaces, causing brittleness in the face of changes as well
as performance problems and making parametrized access difficult.

We propose {\em polymorphic identifiers} as a reified and open replacement for both
language- and user-provided identifier mechanism. 


\end{abstract}

\category{D.3.3}{Programming Languages}{Language Constructs and Features}

\terms{language, design}
\keywords{polymorphic identifiers} % NOT required for Proceedings
\setlength{\epigraphrule}{0pt}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Introduction}

We report on an experimental
technique for expanding our ability to directly name and reference many different 
resources
in programming languages using a common identifier and identifier resolution
mechanism.
These \emph{polymorphic identifiers} are not only user-extensible,
but can also be manipulated in the programming language, making them first class 
entities.

Our starting point is Smalltalk, where we have objects
that communicate via messages\cite{Goldberg1983}.   Identifiers are used to identify 
objects, but are early bound by the compiler.  Late-binding of names, encapsulation,
and polymorphic behavior can only be achieved via message-sends.


Identifiers that need to point to other entities or be used in different ways must be defined
by the programmer and cannot be used interchangeably with built in identifiers.  

The contributions of this paper are
\begin{enumerate} \item a uniform, composable and extensible resource access mechanism for all
resources in a program, \item  a way of integrating that access mechanism naturally into the language for
direct, {\em identifier oblivious} access and
\item a uniform treatment of references for indirect, {\em identifier aware} access.
\end{enumerate}

In section~\ref{identifiers}, we will look at different ways of accessing resources and see
the shortcomings of those approaches.  In section~\ref{polymorphic-identifiers}, we 
describe {\em polymorphic identifiers} as a reification, abstraction and extension of existing 
identifier lookup mechanisms.  Section~\ref{schemes} gives more details on {\em scheme resolvers},
an important component especially for composability, whereas section~\ref{references} looks
at references, which mediate access.  



%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%





\section{Identifiers}
\label{identifiers}
%\epigraph{When programming a component, the right computation model for the component is the least expressive model that results in a natural program.}{Rule of Least Expressiveness.}


Identifiers that name resources come in many different forms ranging from local,
global or instance variables to names for disk files or URIs pointing to network resources.

\begin{figure}[htbp]
\label{identifier-eval}
\begin{center}
\includegraphics[scale=0.55,page=1]{basic-storage.pdf}
\caption{Generic identifier lookup}
\end{center}
\end{figure}

Whatever the specific type, the relationship between the actual identifier and the
final value looks like figure~\ref{identifier-eval}, with slight variations:   there is
the identifier itself, which is a human-readable character string, there is some sort
of store that has identifiable slots or cells and there is a value stored in one of those
cells.   In order to retrieve a value, the identifier is converted to a value using the
hypothetical {\em ref(identifier)} function and then the reference is used to look up an actual
value from a slot using the {\em value(reference)} function.


We will look at 4 distinct types of identifiers that all follow this basic pattern:  language-supported 
{\em direct reference}, where identifiers directly resolve to values, {\em message-based} lookup
used for encapsulation,
{\em string-based} lookup often used with extensible data structures or filesystem access and
finally reified object access.   While each of these approaches solves a part of the problem,
none of them is satisfactory in the end, either lacking capability and extensibility or leading to
irreducible code-duplication, brittleness and simply cumbersome code.

\subsection{Direct reference}
\label{direct-reference}
Like most programming language, our dialect of Smalltalk\cite{Goldberg1983} allows you to just write 
an identifier by itself, and this will not just reference the slot that the identifier names, but also
automatically retrieve the value stored in that slot.  Storing into the slot is accomplished with
the assignment operator {\tt :=}.    Assuming I have a variable that contains {\tt theAnswer} to 
life, the universe and everything, I can access it as shown in listing~\ref{variable-lookup}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=variable-lookup,caption=Interacting with a local resource.]
  theAnswer.
  theAnswer := 42.
\end{lstlisting}
\end{figure}

Due to the fact that the programmer does not, and cannot, deal with either the identifier
or the reference, but names the value using the identifier, we call this an {\em identifier oblivious}
access.  This type of direct access is only possible for a few specific variable types
(local, instance, class, pool and global) and supported directly by the compiler.

If it were possible to make the lookup explicit, what we call {\em identifier aware},
the code would look something like listing~\ref{reified-variable-lookup}.  Apart
from the infinite recursion ({\tt thisContext}  also needs to be looked up),
forcing this style would be prohibitive from both effort/readability and performance
perspectives.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=reified-variable-lookup,caption=Reified local resource access.]
  (thisContext slotAtName:'theAnswer') get.
  (thisContext slotAtName:'theAnswer') set:42.
\end{lstlisting}
\end{figure}

Whereas using this type of direct access with non-local objects is considered at least
questionable style in languages that support it, such as Java or C++, it is simply prohibited in Smalltalk.
The reason is that syntactically direct access is conflated with machine-level direct
access:  the implementation is a straight memory reference, without any possibility
of providing alternative storage strategies or intervening programmatically.

Languages with pointers such as C++ and Objective-C can provide a reference to a variable
by taking the address using the {\tt \&} operator ({\tt \&theAnswer}).   However, this is once
again a direct memory reference without any encapsulation or options of providing 
alternate implementations in the future.  Smalltalk once again prohibits such access.

\subsection{Message-based access}

Encapsulation and the potential for polymorphic behavior can be achieved by using
messages to access the value in question.  Listing~\ref{variable-lookup} shows 
obtaining or setting {\tt theAnswer} by interacting with the {\tt deepThought}\cite{adams1997hitchhiker} object,
as shown in listing~\ref{message-access}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=message-access,caption=Asking an object.]
  deepThought getTheAnswer.
  deepThought setTheAnswer:42.
\end{lstlisting}
\end{figure}

Due to the fact that resource access is hidden behind a message send that will cause
a method to execute, the client does not know wether {\tt deepThought} will just
quickly return a stored representation or instead go off to compute the answer for 
several hundred million years. 

While this level of encapsulation, with its potential for polymorphic behavior, is 
beneficial, it does come at a cost:   instead of the factored 
representation of an identifier and two verbs, {\tt get} and {\tt set},
this is multiplied out for each and every visible attribute of 
each and every class. 
 
The code duplication doesn't stop with preventing the factoring of the get and set 
actions for each
named resource:  we also 
must provide two trivial accessor methods like the ones in listing~\ref{trivial-accessors} for each actual resource we wish
to access.  Studies show that around 5\% of Java code consists of such trivial accessors\cite{Spinellis:2002:MPC:510857.510868}, and although the authors of said study argue that this is {\em not} enough
to warrant special treatment, it should be noted that the prevalence of actual polymorphic 
message sends is also reported to be around 5\% \cite{Holzle:1991:ODO:646149.679193}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=trivial-accessors,caption=Trivial accessors.]
getTheAnswer
    ^theAnswer.

setTheAnswer:newAnswer
    theAnswer := newAnswer.

\end{lstlisting}
\end{figure}

As we should expect, all that unfactored code gets us into trouble if we want 
to make changes:   if we want to globally change how the {\tt set}
operation works, for example, either because we want a different storage
mechanism or some additional behavior,
we must manually change the trivial accessor for every attribute to which
we want to apply this change, because we combined the attribute and
the generic operation into one attribute-specific operation.
\mpw{a little cumbersome}


As long as we can compute messages to send at runtime,
passing references to message-accessed resources is easier than with
direct references.  However, it still poses challenges, because we have decomposed
access to the resource into two distinct messages whose only relationship is by 
convention.  The best we can do when we want to access the resource
is an object that is either initialized with both selectors or can derive them
programmatically (by string manipulation) from the resource name.

\subsection{String-based identifiers}

For the large number of use cases not covered by either direct reference or
message-based access, string-based identifiers interpreted at runtime 
seem to be the implementation method of choice.  Listing~\ref{string-identifiers}
gives a small sampling from one programming environment.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=string-identifiers,caption=Variants of string-based identifiers.]
deepThought valueForKey:'theAnswer'.
deepThought setValue:42 forKey:theAnswer.
aDictionary objectForKey:'theAnswer'.
aDictionary setObject:42 forKey:'theAnswer'.
NSDefaults standardUserDefaults
	 objectForKey:'theAnswer'.
NSDefaults standardUserDefaults
	 setObject:'42' forKey:'theAnswer'.
NSString stringWithContentsOfFile:'theAnswer.txt'
'42' writeToFile:'theAnswer.txt' atomically:YES.
UIImage imageWithContentsOfFile:'answerImage.png'.
UIImage imageNamed:'pictureOf42'.
\end{lstlisting}
\end{figure}

String-based identifiers are used for dynamic access to objects (1,2), 
in dynamic, run-time extensible data structures such as
dictionaries (3,4)  for custom storage mechanisms such as persistent
user defaults (5-8), for generic (9,10) or type-specific (11) file access, cached
access to named application resources (10) and to construct URLs (13,14)
for later use (15).

Since the strings themselves don't carry semantics for the programming language,
they must be handed off to a runtime interpreter, which then performs the actual access.  The 
interpreter can be as simple as a  string lookup into a dictionary,
but it must always be specified in addition to the string.  Listing~\ref{string-bloat}
shows how having to specify this interpreter obscures intent by adding syntactic
noise compared to direct messaging, code bloat that cannot be removed by factoring.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=string-bloat,caption=Bloat with keyed access.]
universe setObject:(deepThought objectForKey:'theAnswer')
	 forKey:'answer'
universe setAnswer:deepThought theAnswer.
\end{lstlisting}
\end{figure}

Apart from the performance costs and the inability of the compiler to help
even check well-formedness of string-based identifiers, there is the problem
of context when using identifiers as references, illustrated in listing~\ref{parametrized-reference}:
we have the string-based identifier {\tt 'theAnswer'}, which we have placed into the
variable {\tt answerReference}.   However, the reference is not self-contained, we
have to know what exact type of container is used and use the appropriate message
to interpret the string, either {\tt valueForKey:} for a generic object or {\tt objectForKey:}
for a dictionary and {\tt stringWithContentsOfFile:} for a file.


\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=parametrized-reference,caption=Indeterminate references.]
answerReference := 'theAnswer'.
deepThought valueForKey:answerReference.
dictionary objectForKey:answerReference.
NSString stringWithContentsOfFile:answerReference.
\end{lstlisting}
\end{figure}

In fact, an expression like {\tt dictionary objectForKey:answerReference} can really
be considered a compound identifier {\tt dictionary.<answerReference>} with
a literal part ({\tt dictionary}) and a parametrized part ({\tt <answerReference>}).

We could ameliorate the situation slightly by having a single universal protocol
for string-identifier lookup, but that makes the actual message essentially
meaningless and thus even more syntactic noise, and also means that we need
to somehow differentiate the lookup scope within the string identifier.   The
{\em schemes} used in URIs to differentiate lookup scopes are a potential
solution.


\subsection{Reified identifiers}


Another way of solving the context problem illustrated in listing~\ref{parametrized-reference} 
is creating an actual reference object that carries the lookup
semantics with it, but as shown in listing~\ref{reified-identifiers},
this increases code bloat even more, and we still have to specify the initial identifier as string.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=reified-identifiers,caption=Reified identifier.]
answerURL := NSURL URLWithString:
	'http://www.depthought.com/theAnswer'.
NSData dataWithContentsOfURL:answerURL.
\end{lstlisting}
\end{figure}



\subsection{Discussion}

Although resource access is one of the most basic operations in a programming, combining
with traits we have come to expect from object-orientation such as encapsulation, polymorphic
behavior and user-extensibility turns out to be surprisingly difficult.   All the potential names
we have available (plain identifiers, message names and strings) fall short:  direct references
using plain identifiers don't' have the features we would like, messages incur code bloat
and brittleness and string identifiers suffer from indirectness, runtime evaluation and more
code bloat, and reifying also does not help.

A solution would need to combine the expressiveness of direct references and the universality
of polymorphic message sends with the extensibility and flexibility of string-based identifiers.


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Polymorphic Identifiers}
\label{polymorphic-identifiers}
%\epigraph{A change in perspective is worth 80 IQ points}{Alan Kay}

The irreducible code duplication and frequent need to embed (mini-)languages into the
source code as strings we saw in section~\ref{identifiers} suggests that the issue needs to be
solved at the linguistic level.

Instead of using messaging or strings to get polymorphic resource access, polymorphic identifiers
generalize direct references  just like messaging generalized function calls and made them polymorphic.
Polymorphic identifiers combine the techniques for resource access discussed in the previous 
section by:
\begin{enumerate}
\item extending the syntax for identifiers to that of Universal Resource Identifiers (URIs)\cite{rfc3986},
\item reifying the identifier lookup process and
\item making it user-extensible with open-implementation techniques.
\end{enumerate}

Listing~\ref{polymorphic-identifier-examples} recasts the examples from section~\ref{identifiers} using
polymorphic identifiers.  Lines 1-4 are just direct references corresponding to section~\ref{direct-reference},
with or without the (default) {\tt var} scheme that is used for in-memory variable accesss.  
Lines 5-6 shows access to an object's attribute, which corresponds to section~\ref{message-access} and is
mediated by the object, using message sends or other means at the object's discretion.  Whether messaging
is used to implement the access is encapsulated as an implementation detail.  Lines 7-14 correspond
to the string-reference examples in listing~\ref{string-identifiers}, line 15 to the reified URL reference
in listing~\ref{reified-identifiers} and line 16 to the parametrized reference in listing~\ref{parametrized-reference}.

\begin{figure}[htbp]
\begin{lstlisting}[style=numbers,label=polymorphic-identifier-examples,caption=Some variants of polymorphic identifiers.]
theAnswer.
theAnswer:=42.
var:theAnswer.
var:theAnswer:=42.
var:deepThought/theAnswer.
var:deepThought/theAnswer := 42.
var:aDictionary/theAnswer.
var:aDictionary/theAnswer := 42.
defaults:theAnswer.
defaults:theAnswer := 42.
file:theAnswer.txt.
file:theAnswer.txt := 42.
file:answerImage.png.
img:pictureOf42.
http://www.depthought.com/theAnswer.
var:aDictionary/{answerRef}
\end{lstlisting}
\end{figure}

Figure~\ref{scheme-eval} shows the generic identifier lookup of figure~\ref{identifier-lookup}
extended to polymorphic identifiers.  The basic mechanism is still the same except for the
addition of {\em scheme handlers} mediating the lookup process.  The left hand side of the
diagram corresponds to the lookup in figure~\ref{identifier-lookup}, with the difference that
the lookup that was previously hardwired into the language is now mediate by the {\tt var}
scheme handler, which in turn was selected by the {\tt var} scheme that's part of the 
polymorphic identifier.


\begin{figure}[htbp]
\label{scheme-eval}
\begin{center}
\includegraphics[scale=0.45,page=1]{scheme-evaluation.pdf}
\caption{Polymorphic Identifier lookup}
\end{center}
\end{figure}


The right hand side of figure~\ref{scheme-eval} shows fetching of a web-resource from
a remote server following the same four step lookup process:

\begin{enumerate}
\item a character sequence is turned into  polymorphic identifier,
\item the scheme part of the polymorphic handler is used to select a scheme handler, in this case the {\tt http} handler,
\item the scheme handler evaluates the {\em scheme-specific} part of the polymorphic identifier ({\tt //deepThought.org/theAnswer})
	 and returns a reference, in this case a web-reference,
\item this (web-)reference mediates access to the actual resource, in this case translating requests to store or retrieve the 
	resource into HTTP GET or PUT requests via an http client library.
\end{enumerate}

These four steps can happen at compile- or run-time and can be partially completed.
A reference to a local stack variable, for example, will typically have none of the
three components visible at run time, with all that remains being optimized 
machine code to directly access the resource (the stack variable).
A file or web-reference, on the other hand, will typically have the PI itself
compiled, with evaluation deferred until runtime.  Finally, there are facilities
for turning strings into PIs at runtime.


\section{Schemes and scheme handlers}
\label{schemes}
Schemes are the main point of variability in the PI system
and broadly fall into two categories:   {\em primitive schemes}(\ref{primitiveSchemes})
directly encapsulate access to some sort of resource, while {\em composite schemes} 
take other schemes as arguments and modify their behavior.


Users can define their own schemes and add them 
to the system, either by writing
a new primitive scheme handler, by applying composite schemes or by writing new types
of composite scheme handler.  Built-in schemes are not privileged over user-defined
schemes except where necessary to avoid infinite recursion.

Scheme handlers are normal objects that respond to a well-defined protocol.  They
become part of the language by adding them to a special scheme, the {\em scheme scheme}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=scheme-scheme-http,caption=Adding the http and file schemes.]
  scheme:http := URLSchemeResolver scheme.
  scheme:file := FileSchemeResolver scheme.
\end{lstlisting}
\end{figure}

Listing~\ref{scheme-scheme-http} shows the binding of the {\bf http} and {\bf scheme}
handlers to actual (primitive) scheme handlers that will subsequently process any polymorphic
identifiers with the {\tt http} or {\tt file} schemes, respectively. 

It is both possible and common to bind other handlers to those scheme
names, for example an {\bf http} handler that implements a multi-level caching scheme
or a {\bf file} scheme served from memory for testing purposes.  Any scheme-handler
can be used for any scheme-name, as long as it implements the handler protocol
compatibly.

Note that perfect interoperability is not guaranteed or required, so there is no notion
of transparent remote access, for example.  Different scheme handlers will have different supported
data types, different access modalities and different levels of quality of service.
Polymorphic identifiers only remove accidental, mostly syntactic, incompatibility for accessing different types
of resources when those resources are semantically compatible within the parameters
of the requesting application.


The {\em scheme scheme} can also be queried,
so the expression {\bf scheme:http} returns the currently installed http handler, and 
{\bf scheme:scheme} returns the scheme scheme itself, which will list the currently
installed schemes.  Listing~\ref{scheme-scheme} shows the schemes installed by
default in the scripting environment {\tt stsh}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=scheme-scheme,caption=List of schemes via scheme:scheme.]
> scheme:scheme 
scheme-resolver with the following schemes: (
    file,
    ftp,
    default,
    var,
    bundle,
    defaults,
    sel,
    mainbundle,
    scheme,
    http,
    env,
    class,
    https
)
\end{lstlisting}
\end{figure}

\subsection{Primitive Schemes}
\label{primitiveSchemes}

Primitive schemes are the endpoints for resource access, they directly
mediate access to the resource in question.  Primitive schemes
subsume both what is normally considered variable access and 
what is usually considered I/O, network and filesystem access.

Primitive schemes are components with only an output port.

\subsubsection{External resources}
\label{externalResources}

The list of default scheme-handlers in listing~\ref{scheme-scheme} contains a few familiar URI schemes:
{\tt http} and {\tt https}, {\tt ftp}, {\tt file}.   These behave in the expected way:   referencing them in an expression will
retrieve the bytes from the web-server, FTP-server or file, and placing them on the left hand side of
an assignment statement will perform an HTTP or FTP PUT request or write to a file system.



\subsubsection{In-memory resources}
\label{inmemory}

So far, we have simply added file and Web-access via URLs to a 
Smalltalk-like programming language.  However it turns out that we can actually generalize
this approach to all identifier usage, including normal variable access, using
two additional schemes:  the {\bf var} scheme and the {\bf default} scheme.

The {\bf var} scheme refers to in-memory variables, so the expression
 {\bf var:anObject} references the
local variable {\bf anObject}.   Compound paths can be given and are resolved in
cooperation with the object.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=in-memory-path,caption=In-memory access path.]
  myColor := var:robot/head/leftEye/color.
  var:robot/head/leftEye/color := myColor.
\end{lstlisting}
\end{figure}

Listing~\ref{in-memory-path} recasts the structured access from 
Listing~\ref{non-local-reference} using \emph{polymorphic identifiers}.  Unlike the variant
with chained message-send, the operations are symmetric in the case of \emph{polymorphic identifiers}.

The {\tt thread} scheme encapsulates thread-local variables using the {\tt pthread} thread
local storage API and the {\tt dyld} scheme encapsulates dynamic access to
named variables via the {\tt dlsym} family of functions.

A scheme that straddles the fence between an in-memory and an external 
scheme is the {\tt env} scheme, which encapsulates access to the Unix
environment via the {\tt getnv()} and {\tt putenv()} functions.  Although 
values are not stored in persistence storage, they can outlast the
current process and also need to be serialized into character sequences.

A further scheme handler that is not pre-loaded but available for defining
custom schemes is the {\tt SiteMap}.  A {\tt SiteMap} stores arbitrary objects
in memory in a tree structure that acts a bit like a memory filesystem.

\subsection{Composite Schemes}

Composite schemes  create a new scheme by combining one or 
more existing schemes and applying processing to the identifiers, retrieved
resources or both.

\subsubsection{Relative Scheme}

One example is the relative scheme resolver, which takes a base-binding
and evaluates its references relative to that base.  Listing~\ref{rfc-scheme} shows
how to use a relative scheme resolver to build a scheme that can directly
reference Internet Engineering Task Force Request For Comments (IETF RFCs).
The end effect is that we can hide the actual location and access method for
the IETF RFCs behind a scheme so we can access those RFCs directly and
creating a URI scheme that is close to a URN.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=rfc-scheme,caption=Retrieving RFC 2396 (URI Syntax) via custom rfc: scheme.]
  base := ref:http://datatracker.ietf.org/doc/.
  scheme:rfc := RelScheme schemeWithBase:base.
  uriSyntax := rfc:rfc2396.
\end{lstlisting}
\end{figure}

\subsubsection{Binary Scheme}

\mpw{do sequential lookup here, for Fielding's IETF/RFC example
	and lookup rules for variables (local, instance, ... )}

Another is a cache scheme, which has two schemes as its arguments,
the base and the cache.  When accessed, the cache scheme first
checks the scheme that was designated as its cache.  If the resource
is found there, it is returned.   If the resource is not found in the cache
it is retrieved from the base scheme and placed in the cache in addition
to being returned.

Using the http- and file-schemes from section~\ref{externalResources}, the
{\tt SiteMap} from section~\ref{inmemory} and the cache and
relative schemes defined here, we can create the 
caching behavior of a typical http stack just by composing
pre-existing schemes, as shown in figure~\ref{http-cached}.


\begin{figure}[htbp]
\label{http-cached}
\begin{center}
\includegraphics[scale=0.5,page=1]{cached-http.pdf}
\caption{A caching http stack made from composed schemes}
\end{center}
\end{figure}

The code to implement this composed, caching http scheme is not all 
that different from the diagram.  It is shown in listing~\ref{http-composed-listing}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=http-composed-listing,caption=Code for caching http stack.]
rawhttp := scheme:http.
tempdir := ref:file/tmp/ asScheme.
filecache := CacheScheme cacheWithScheme: tempdir.
memcache := CacheScheme memoryCache.
scheme:http := 

 rawhttp -> filecache -> memcache.
\end{lstlisting}
\end{figure}

The {\tt ->} connector composes components by their default input
and output ports.

The cache-scheme is really just a special case of a binary composite scheme,
which can be also be used to implement copy-on-write behavior similar to
VPRI's world concept\cite{vpriworlds}.

A {\em filter-scheme} applies custom processing to the identifiers going to
its source scheme and the data flowing in and out.  The block filter-scheme
takes a block for each 

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=http-cached-converted-listing,caption=Caching and converting.]
mapper := MIMEMapper defaultMapper.
scheme:http := 

 rawhttp -> filecache -> memcache -> mapper.
\end{lstlisting}
\end{figure}


 A special case of the 
filter scheme is the mime-mapper.  It turns serialized data obtained from
external resource schemes such as {\tt file} or {\tt http} into domain objects
using blocks keyed by mime-type.  

\begin{figure}[htbp]
\caption{Adding conversion to the caching http-stack}
\label{http-cached-converted}
\begin{center}
\includegraphics[scale=0.5,page=1]{cached-and-mapped-http.pdf}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=http-cached-converted-listing,caption=Converting and caching.]
scheme:http := 

 rawhttp -> filecache -> mapper -> memcache .
\end{lstlisting}
\end{figure}


With the mime-type mapper in place, it might make more sense to
cache the deserialized representation in memory rather than
the raw bytes.  This change in caching strategy only requires
the minimal change in the configuration of the composed http-scheme
shown in figure~\ref{http-converted-cached}.

\begin{figure}[htbp]
\caption{Caching the converted object}
\label{http-converted-cached}
\begin{center}
\includegraphics[scale=0.5,page=1]{mapped-and-cached-http.pdf}
\end{center}
\end{figure}

Listing~\ref{http-converted-cached-listing} again closely follows the
diagram in figure~\ref{http-converted-cached}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=http-converted-cached-listing,caption=Converting and caching.]
scheme:http := 

 rawhttp -> filecache -> mapper -> memcache.
\end{lstlisting}
\end{figure}

With the mime-mapper in place in the revamped http-scheme, we can now use 
an image that's stored on a remote server just by writing out its URL, as shown
in listing~\ref{image-drawing}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=image-drawing,caption=Drawing a remote image.]
drawingContext drawImage: http://
\end{lstlisting}
\end{figure}



\subsection{Default scheme}


The {\bf default} scheme is not an actual scheme per-se, but rather a special slot
that is used in resolving identifiers encountered without a scheme-specifier.
In that case, the scheme registered under the {\bf default} scheme is used
instead, which when combined with the {\bf var} scheme that is the default
for the {\bf default} scheme gives the semantics for a naked identifier (e.g. {\bf robot}).

However, the default scheme can be set to some other scheme if that is more
convenient for the task at hand, as shown in Listing~\ref{file-as-default-scheme},
where a file copy is performed after the default scheme is set to file.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=file-as-default-scheme,caption=File copy with file: as default scheme.]
  scheme:default := scheme:file.
  myBashRc := .basrhc.
\end{lstlisting}
\end{figure}

One syntactic limitation of the default scheme mechanism is that it does not allow
compound paths, so for compound paths a full URI with scheme must be used.


\mpw{no changes yet beyond this point}

\section{First class references}
\label{references}
The four-step evaluation process we saw in section~\ref{polymorphic-identifiers} is
actually a convenience 

The bindings that are returned by scheme-resolvers are usually ephemeral, used just 
to get to the value pointed to by the identifier, either reading or writing it.  This
makes it possible to program with arbitrary and user-defined identifiers in
an identifier-oblivious style.  It also means that for sufficiently simple scheme-resolvers,
the binding can actually be elided if the compiler can determine that it is not needed.

However, as we saw earlier, it is sometimes
desirable to use the identifier-aware style.  In order to do this, the language
must provide access to the bindings used in resolving the identifier.

The {\bf ref} scheme prevents evaluation of the binding and thus allows access
to the binding itself.  Listing~\ref{ref-binding} illustrates the syntax and semantics:
first a variable {\bf a} is defined and bound to a value 42, then we obtain a reference {\bf b} to
the identifier for the first variable {\bf a}.  We can now manipulate variable {\bf a} 
in a generic way through the reference we have obtained in variable {\bf b} without
having a hard-coded reference. 


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=ref-binding,caption=Accessing a variable via its binding.]
  a := 42.
  b := ref:var:a.
  b value  -> 42.
  b bindValue:2.
  a -> 2.
\end{lstlisting}
\end{figure}

This generic access to variables (or more generally: resources) can be used just as well
with complex identifiers that have multi-element paths.  So for example a UI element
could get the reference {\bf ref:var:robot/head/leftEye/color} and would then be
able to manipulate the eye-color of the left eye of that particular robot safely using
the message {\bf value} and {\bf setValue:}
without having to know about or traverse the structure in question.

Common operations on bindings are retrieving, binding and unbinding a value and testing 
wether a binding has a value, as shown in Listing~\ref{isBound} for the {\bf env} scheme
that provides access to Unix environment variables.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=isBound,caption=Is environment variable set?]
> ref:env:bozo isBound  -> 0
> env:bozo := 'hi'
> ref:env:bozo isBound  -> 1
\end{lstlisting}
\end{figure}

Bindings are scheme-specific and can include additional API specific to that type of scheme.
For example, file bindings are analogues of the Java {\bf File} object and can deliver
meta-data about and perform operations on the file as shown in Listing~\ref{ref-file-dir}.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=ref-file-dir,caption=File and directory manipulation.]
> newDir := ref:file:testDir 
> newDir isDirectory  -> 1
\end{lstlisting}
\end{figure}

Bindings for remote resources include methods for initiating a transfer, cache-control,
error-checking and progress monitoring.   Bindings can be passed to user interface
elements for manipulation of the object referenced.




\section{Evaluated identifiers}

With richer identifiers, it makes sense to allow abstractions to be built with these identifiers.
One example is parametrization, with an identifier having parameters that are evaluated
at runtime.  Curly brackets \{\} denote a section of the path that should be evaluated and
the return value used as part of the access path.

Listing~\ref{bashrc-pi} shows an example where the current user's home directory
is retrieved from the Unix environment using the {\bf env} scheme and the resulting
path is then used to obtain the current user's  {\bf .bashrc}.
It is equivalent to Listings~\ref{posix-file-resolve}, \ref{cocoa-file-contents}, and 
\ref{sh-file-contents}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=bashrc-pi,caption=Parametrized identifier.]
  file:{env:HOME}/.bashrc
\end{lstlisting}
\end{figure}


Different abstraction mechanisms can be combined, for example yielding
a scheme that represents file in the current user's home directory, shown
in Listing~\ref{home-scheme}.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=home-scheme,caption=Accessing .bashrc via custom home: scheme.]
  base := ref:file:{env:HOME}.
  scheme:home := RelScheme schemeWithBase:base.
  home:.bashrc.
\end{lstlisting}
\end{figure}

A sequential composition scheme simply searches a list of other schemes
for a particular identifier.  It searches its argument schemes sequentially
for the identifier in question and returns the first match.  Lookup rules for
identifiers that are usually hard-coded into languages can be expressed
as a sequential composition scheme, for example:   \{ scheme:local ,
scheme:ivar , scheme:classvar , scheme:poolvar , scheme:global \} for Smalltalk 
(ignoring the capitalization rules for now).

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%



\section{Implementation}
\label{implementation}

\emph{Polymorphic identifiers} have been implemented as part of Objective-Smalltalk \cite{objst},
a Smalltalk dialect built on top of the Objective-C\cite{objc-evol}\cite{objc-apple} runtime, 
in a way that is similar to FScript\cite{fscript} and MacRuby \cite{macruby}.

Objective-C is an ahead-of-time-compiled, hybrid, and dynamic object oriented programming language
that is an extension of C.  The object-oriented extensions to C are closely modeled on
Smalltalk, with dynamic single-dispatch at runtime, a keyword syntax and classes as
largely first-class objects.

Objective-Smalltalk objects and classes are Objective-C objects, they are created using
the same functions and data structures and are indistinguishable at runtime.
The same goes for Objective-Smalltalk methods, which are also indistinguishable from
Objective-C methods, making Objective-Smalltalk in a sense a meta-circular language
that is written in itself, or more precisely written in variants of itself \cite{kleinvm}\cite{squeak}.



\subsection{Example}

Listings~\ref{get-env}-\ref{hasValue-env} show the implementation of a simple scheme,
the env-scheme that provides access to Unix environment variables.  While this scheme
is actually string-based, that fact is hidden and the strings are not exposed to the user.
Listing~\ref{get-env}
shows the {\bf bindingForName:inContext:} method that is the main access point for
converting from an identifier to a binding.  In this case, a generic binding object is returned
that simply stores the name of the identifier and lets the scheme that created it resolve
access via the {\bf valueForBinding:} and {\bf setValue:forBinding:} methods.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=get-env,caption=Basic lookup in env: scheme.]
-(const char*)cstringValueOfBinding:aBinding
{
  return getenv([[aBinding name] UTF8String]);
}

-bindingForName:aName inContext:aContext
{
  return
    [GenericBinding bindingWithName:aName scheme:self];
}

-valueForBinding:aBinding
{
  const char *val=[self cstringValueOfBinding:aBinding];
  if ( val ) {
    return [NSString stringWithUTF8String:val];
  } else {
    return nil;
  }
}
\end{lstlisting}
\end{figure}

In this case, the name of the identifier is simply passed to the POSIX {\bf getenv()} function.
Setting the value is handled in an analog fashion using the {\bf setenv()} function.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=setvalue-env,caption=Set value in env: scheme.]
-(void)setValue:val forBinding:binding
{
  val=[newValue stringValue];
  if ( val  ) {
    setenv([[binding name] UTF8String],
      [value UTF8String],1);
  } else {
    unsetenv([[binding name] UTF8String]);
  }
}
\end{lstlisting}
\end{figure}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=hasValue-env,caption=Checking for presence of value in env: scheme.]
-(BOOL)isBoundBinding:aBinding
{
  return 
    [self cstringValueOfBinding:aBinding] != NULL;
}
\end{lstlisting}
\end{figure}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=url-args,caption=URL arguments via reference and higher order message.]
  host := 'citeseerx.ist.psu.edu'.
  viewCiteSeer:=ref:http://{host}/viewdoc/summary.
  viewCiteSeer getWithArgs doi:'10.1.1.41.7628'.
\end{lstlisting}
\end{figure}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Related Work}
\label{related-work}

There has been a lot of work on extensible languages, but very little of that work 
has focused on identifiers.  

\subsection{Path-based access in languages}

Programming languages such as C, C++ or Pascal have facilities for composite
identifiers, for example using the dot or {\bf -> } operators in C, but these facilities allow
direct access to the internal data, without any ability of the structure in question to 
mediate.  The same thing goes for passing a pointer to a substructure:  while it
does give a single entity that can be used to access a sub-part of a structure, it
does so without any access controls.

Properties in C\# and Objective-C 2.0 allow a variable-access interface to be backed by 
message sending, thus allowing path-based access under dynamic control of the object
in question, but without having first-class references or the ability to access other
types of resources using a unified mechanism.

ThingLab\cite{thinglab}  adds path-based access to the base Smalltalk language in order to support
constraints referencing parts of objects, say the vertex of a triangle, and these
references do exist as first class objects that can be passed to other objects.
   It does not
expand this path-based access to other domains or make it user-extensible.

AppleScript\cite{applescript-hopl3} exposes a program's object model via
phrases that correspond to access path.  Listing~\ref{AppleScript} shows 
how to access the title of the currently playing iTunes track and set this
as the current iChat status message.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label= AppleScript,caption=Using AppleScript to set chat status from track name.]
  tell application "iTunes"
    set trackname to name of current track
  end tell
  tell application "iChat"
    set status message to trackname
  end tell
\end{lstlisting}
\end{figure}

With \emph{polymorphic identifiers}, the same operation can be expressed
much more concisely as a simple assignment between two URIs,
as shown in Listing~\ref{NonAppleScript}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=NonAppleScript,caption=Access to applications via \emph{polymorphic identifiers}.]
  app:iChat/statusMessage := app:iTunes/currentTrack/name.
\end{lstlisting}
\end{figure}


\subsection{Unified path-based access mechanisms}


User level filesystems like FUSE\cite{fuse} or the BSD Pass-to-User-Space\cite{puffs} 
system allow
user-level code to add new filesystems to the Unix kernel, without requiring
kernel modifications or impacting operating system kernel stability.

This approach allows many sorts of local and remote data-types to be 
treated as files in a filesystem and made available to the wide variety
of Unix tools that can navigate and process such files.  

However, this support requires global installation of handlers in the operating
system, which also must mediate access, making integration of in-memory 
variables difficult at best.  The identifiers used to access these resources
are also still strings that are not integrated with the identifier mechanism of
the host language, with all the problems discussed in Section~\ref{stringtrouble}.

Using FUSE/puffs filesystems as scheme resolvers without kernel intervention seems
like a useful addition, as is making scheme-resolvers available to the Unix kernel
via FUSE/puffs.

The Plan9\cite{plan9names}\cite{plan9network} operating system from Bell Labs goes further than FUSE in integrating
all data, local and network resources into a single hierarchical namespace.  Similar
caveats as for FUSE apply.

Phantom XML\cite{phantomxml} unifies access to data by treating all data as
XML trees, allowing queries against this XML representation of the data without
actually converting it to XML first.  




\subsection{URIs in E}

The E language\cite{MillerRobustComposition}  supports URI-Expressions as a
direct language feature.  Example include access to files
using file URI  {\bf <file:c:/jabbertest>} or Web-resources using HTTP {\bf <http://www.erights.org>}.  However,
E only supports using these URI expressions in the reference-aware style and does not integrate 
ordinary identifiers into the URI mechanism, provide abstraction facilities 
for URIs or an extension mechanism. 


\subsection{References in Icon}

In the Icon programming language \cite{IconRef} , identifiers (references) can be first class values,
and there are complex rules for when a reference remains a reference and when
it's value is used.  However, the rules are implicit and there is no way for the 
developer to choose when to be identifier-aware or identifier-oblivious.  Furthermore,
there is no way for the user to extend the language with new types of references 
or behaviors.



\subsection{Domain specific languages}

\emph{Polymorphic identifiers} are similar to Embedded Domain Specific Languages\cite{edsl}
in that they allow domain-specific language elements to be added to a language, rather
than having to create a completely new language with an external DSL or attempt to 
achieve the desired effect with an internal DSL\cite{fowlerdsl}.  

Like polymorphic embedding of DSLs \cite{polydsl}, \emph{polymorphic identifiers} allow
a single syntax to be used with multiple, pluggable semantic interpretations permitting
composition of functionality\cite{embeddeddsl}.  However, \emph{polymorphic identifiers}
are applicable to general purpose programming languages, not jus DSLs, while
at the same time restricting their focus to just the identifiers used.

\subsection{Proxies, mirrors, and mirages}

Smalltalk reflective facilities \cite{reflective-st} have long been used to build
facilities such as distributed object systems, futures, lazy evaluation and
transparent storage mechanisms.  One problem with the Smalltalk facilities
has been that they are defined in an ad-hoc fashion from error handling routines
and not sufficiently stratified, with meta-level functions
interfering with base-level functions and vice-versa.  Another problem is that
most reflective techniques only apply to messages, not to identifiers, making 
those techniques unavailable.

Mirrors \cite{mirrors} and Mirages \cite{mirages} improve the stratification and
reflection/intercession capabilities, but are not capable of dealing with pure
identifiers or of bringing user-defined resource handlers into the language.

The proposed ECMAScript Proxy mechanism \cite{VanCutsemMiller} addresses
the stratification issues and also integrates some identifier access into the 
metaprogramming framework, but doesn't allow user-extensible identifiers.

We believe that mechanisms such as remote objects, futures, proxies and the like
are actually properly modeled not at the object level, but at the identifier/reference
level, so that a significant part of what is currently considered metaprogramming
can be considered programming at the identifier level.

\subsection{Internet programming languages and systems}

The success of the REST architectural style\cite{fielding-rest} on the Web has sparked
systems and languages that try to more directly model and take advantage of that
style.

The Wheat language \cite{wheat} embedded an entire programming language
and system into a Web-server, accessing all resources and methods via
HTTP URLs.  \emph{Polymorphic identifiers} allow resources, but these resources
are not required to use a specific communications mechanism.


Resource Oriented Computing \cite{roc} goes even further by
requiring all computation to be expressed through URIs, adding Active URIs
for computation as shown in Listing~\ref{activeuri}.   


%\begin{figure}[htbp]
%\begin{center}
%\begin{small}
%\begin{verbatim}
%active:{base}+{name}@{uri}...
%\end{verbatim}
%\end{small}
%\caption{Active URI}
%\label{activeuri}
%\end{center}
%\end{figure}

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label= activeuri,caption=Active URI.]
  active:{base}+{name}@{uri}...
\end{lstlisting}
\end{figure}

The {\bf base} is a function name, the {\bf name} an argument name and the
{\bf uri} an argument URI.
 While \emph{polymorphic identifiers} allow processing to be
hidden behind a resource URI, they also allow messaging to be expressed
as messaging when that is the intent.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Summary and Outlook}
\label{summary-and-outlook}

We examined both built-in and user-defined identifiers in programming languages 
and separated their usage patterns into an {\em identifier-oblivious} style where
the identifier is used by itself to denote its bound value and the 
an {\bf identifier-aware} style where the identifier itself is used as a first class value
and its value can only be accessed indirectly.

While each style is appropriate in different usage-scenarios, current languages 
tie the usage style to wether the identifier is built-in or user-defined.  \emph{Polymorphic
identifiers} remove the distinction between user-defined and built-in identifiers by having
a single type of user-extensible identifier that can be used in both identifier-oblivious
and identifier-aware styles.

With a user-extensible identifier architecture, it becomes possible to add abstraction
and information-hiding capabilities to identifiers and expand the use of REST-style
programming beyond network and Web-environments.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

%\appendix
%\section{Appendix A}

%This is the text of the appendix, if you need one.

%\acks

%Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\vfill
\break

\bibliographystyle{abbrv}

% The bibliography should be embedded for final submission.
\bibliography{polymorphic-identifiers}

\balancecolumns
\end{document}
