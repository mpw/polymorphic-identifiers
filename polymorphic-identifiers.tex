%-----------------------------------------------------------------------------
%
%    Domain Specific Identifiers
%
%-----------------------------------------------------------------------------


\documentclass[preprint,authoryear]{acm_proc_article-sp}


\usepackage{amsmath}
\usepackage{epigraph}
\usepackage[colorlinks=true,
        linkcolor=blue,
        citecolor=red,
        filecolor=black,
        pagecolor=black,
        urlcolor=black,
        bookmarks=true,
        bookmarksopen=true,
        bookmarksopenlevel=3,
        plainpages=false,
        pdfpagelabels=true]{hyperref}

\begin{document}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2011} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Polymorphic Identifiers}
%\subtitle{Subtitle Text, if any}

\numberofauthors{2}
\author{
\alignauthor Marcel Weiher\\
       \affaddr{metaobject ltd.}\\
       \email{marcel@metaobject.com}
\alignauthor Robert Hirschfeld\\
       \affaddr{Hasso Plattner Institut}\\
       \email{hirschfeld@acm.org}
}

\maketitle

\begin{abstract}
We introduce polymorphic identifiers, a generalization of the monomorphic identifiers found in most
programming languages today as first class objects, as well as mechanisms for
resolving those identifiers and binding them into a general purpose programming language.
These identifiers allow stratified designs clearly separating meta- and base-level constructs
as well as light-weight domain-specificity with high levels of expressiveness, 
\end{abstract}

\category{H.4}{Information Systems Applications}{Miscellaneous}

\terms{Language Design}
\keywords{ACM proceedings, DLS, Dynamic Languages} % NOT required for Proceedings
\setlength{\epigraphrule}{0pt}


\section{Introduction}
\epigraph{There are only two hard things in Computer Science:  cache invalidation and naming things} {Phil Karlton}

This is not a paper about cache invalidation.  Mostly.   Rather, we report on an experimental
technique for expanding our ability to directly name many different things in 
programming languages using a common and extensible identifier and identifier resolution
mechanism.
These polymorphic identifiers are not just user-extensible,
but can also be manipulated in the programming language, making them first class 
entities.

Our starting point is a programming model such as that of Smalltalk, where we have objects
that communicate via messages\cite{Goldberg1983}.   Identifiers are used to identify 
objects, but are early bound by the compiler and resolved to slots in local contexts, and 
global, instance-, class- or pool-variables.  Late-binding of names, encapsulation and
polymorphic behavior can only be achieved with message sends.

We then give various examples both of additional things that one might want to reference 
 apart from objects resident in a single address space  and
desirable operations on identifiers beyond resolving them to objects at compile time.

We believe that the accidental complexity \cite{Brooks87nosilver} introduced by the
plethora of ad-hoc mechanisms for addressing these desiderata can be reduced 
by unifying them using the polymorphic identifiers introduced in this paper.


\section{Identifiers}
\label{identifiers}
\epigraph{When programming a component, the right computation model for the component is the least expressive model that results in a natural program.}{Rule of Least Expressiveness.}

Identifiers are symbols that serve as human-readable names for entities/objects
in a program.  They are converted to actual references, usually with a mixture of
compile-time and run-time lookups.  For example, to obtain the value of the local
variable named {\bf anObject}, one would have to search the local context for
a slot named {\bf 'anObject'} and then return the value stored at that slot.


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
(localContext variableNamed:'anObject') value.
\end{verbatim}
\caption{Lookup of a local variable}
\label{variable-lookup}
\end{center}
\end{figure}


Some  languages actually perform all these steps at runtime, but most 
have a compiler help with efficiency by converting the names to indexes into
the local context and the value lookup into a simple indexed load from memory.

Most programming languages don't just optimize the implementation of the identifier
lookup operation, but also the interface.  Instead of having to specify how to
look up the identifier in the local context, the programmer can just write the
identifier {\bf anObject}, which the programming language will treat as equivalent to the
value that will be obtained by looking up the name in the local context.  


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	anObject.
\end{verbatim}
\caption{Identifer-oblivious variable lookup}
\label{plain-identifier}
\end{center}
\end{figure}

This  {\em identifier-oblivious} style shown in Figure~\ref{plain-identifier}, where lookup of the value bound to and
identifier is implied, is so familiar that we don't usually think about it, we just
refer to object using the identifier.
  The 
alternative {\em identifier-aware} style shown in Figure~\ref{variable-lookup} would get cumbersome quickly.

Non-local entities such as sub-parts of constructed objects 
cannot be referred to symbolically by a single identifier.
Instead, they must be obtained using computation, a 
sequence of operations, which in Smalltalk is performed using message sends.
For example, assuming we have a model of a robot, we might obtain the
color of the robot's left eye as follows:

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	robot head leftEye color.
\end{verbatim}
\caption{Obtaining a reference via chained message sends}
\label{non-local-reference}
\end{center}
\end{figure}


Although we can hide an object reference behind a computational interface, we cannot
hide a computation behind a object reference interface.
Thus any kind of external API has to be presented through a computational, messaging 
interface, even if the intention is not computation, but just access to a resource,
  and all information hiding also requires messaging.  This has led languages
like Self \cite{UngarS87} and Newspeak \cite{newspeak} to effectively abandon identifiers as symbolic names for objects, 
all objects are instead obtained by sending messages to other objects.

On the World Wide Web with its REST architectural model the situation is exactly the reverse: 
 the interface
to resources is their identifier, the Uniform Resource Locator (URL).   Wether
computation happens in providing the resource is a hidden implementation detail
(ignoring the messaging protocols usually required to transmit the resource
to the client).  


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
http://www.shipper.com/track/12345678
\end{verbatim}
\caption{A Uniform Resource Locator}
\label{url-example}
\end{center}
\end{figure}

So instead of having
a package-tracking application that takes a parameter (2 entities),
one can simply take the view that ``every package has its own 
web-site'', which is then just one entity referenced by a single,
parameterless identifier.  This type of encapsulation behind
a single, parameterless identifier makes bookmarks and single
browser-based navigation possible.


 Instead of hiding references behind messaging,
messaging is hidden behind an identifier, and RESTful web applications
perform computations by dereferencing a series of identifiers, that 
are provided incrementally and dynamically in responses.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
urn:isbn:123123123
\end{verbatim}
\caption{URN}
\label{urn-example}
\end{center}
\end{figure}

Whereas URLs specify an access path, including a network protocol, Uniform 
Resource Names like the ISBN in Figure~\ref{urn-example} just specify a logical
name, leaving the resolution of that name completely open.  In a sense, URNs
correspond to interfaces 

Uniform Resource Identifiers are a generalization of both Uniform Resource Locators
and Uniform Resource Names.  

URIs are a generalization of Uniform Resource Locators, which specify a
resource by its network location and access path and Uniform Resource Names,
which specify
a resource by a logical name and leave it to system processes to 
determine the exact location.  In practice, most URIs are located on
a continuum with URNs on one end and URLs on the other.

\section{User-level identifiers}


In addition to the entities that can be referred to directly by the programming language's 
built-in identifiers, there are many other entities and situations where that is not possible.
However, entities still need to be addressed, so developers are required
to construct their own identifiers or references and methods for resolving them to the actual
entities.

\subsection{External Resources}

Files, for example are referenced by their filename, or more precisely
a string that represents their access path in the filesystem from the root 
directory.   The operating system is responsible for mapping these full
paths to entities allowing access to the contents of the file.  For example accesing
the current user's ``.bashrc'' file looks as follow:

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
   char fullname[MAXPATHLEN];
   snprintf(fullname,MAXPATHLEN,"%s/.bashrc",
                            getenv("HOME"));
   int fd = open( filename );
   if ( fd >= 0 ) { 
      //... read contents of file using read()
      close(fd);
   }
\end{verbatim}
\caption{Resolving a name in the user's home directory to a file}
\label{posix-file-resolve}
\end{center}
\end{figure}

The string represents a user-level identifier, which is just a plain character
string that has no meaning to the programming language and must be 
manually resolved by the developer in the {\em identifier-aware} style 
introduced in Section~\ref{identifiers}.  In fact, two different identifiers
are resolved in Figure~\ref{posix-file-resolve}:  first, the identifier {\bf HOME}
from the domain of environment variables is needed, which requires calling
the {\bf getenv()} function to resolve the identifier string to a value.  That result,
also a string, is then combined with the name of the file in question and passed
to the {\bf open()} system call to return an actual file reference.  Boundary conditions
and error checking have largely been elided.

Convenience APIs can ameliorate the situation somewhat, for example shortening 
the multiple steps above into a single (slightly verbose) expression and making the
string processing safer.  However, they cannot
change the fundamental fact that the identifiers in question are basic strings,
manipulating them requires string processing and user-level resolution of the
string to an entity.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
   NSData dataWithContentsOfFile:
     ((NSProcessInfo processInfo
        environment 
        objectForKey:'HOME') 
       stringByAppendingPathComponent:'.bashrc')

\end{verbatim}
\caption{Cocoa convenience API for accessing file contents}
\label{cocoa-file-contents}
\end{center}
\end{figure}


Which identifiers we can use in an oblivious style and which we need to
be aware of and resolve ourselves is pre-determined by the programming
language.
The same identifier that needs to be created using string processing from various
components in both the POSIX and the Cocoa can be written directly in a typical
Unix shell, including the variable part.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	cat $HOME/.basrhc
\end{verbatim}
\caption{File contents in a shell}
\label{sh-file-contents}
\end{center}
\end{figure}

The lack of string quotes is not just cosmetic: both the variable and the filename
are not just opaque strings, but entities that the shell is aware of and can identify
using the identifiers provided,for example being able to assist by autocomplete 
or wildcard expansion.



\subsection{Dynamic data structures}

Path-based access is not restricted to external resources, but also
prevalent when accessing dynamic data structures

 such as an XML DOM (xpath)

\begin{itemize}
\item [mpw] more details
\end{itemize}

\subsection{User Interfaces}




\subsection{Network Resources}



\subsection{The Trouble with Strings}
\label{stringtrouble}
\epigraph{The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.}{Alan Perlis}


One aspect that virtually all user-level identifier mechanisms have in common is that they
are based on string processing.  The use of strings makes user-level identifiers relatively
close to language identifiers ({\bf \hbox{anObject}} vs {\bf \hbox{'anObject'}}), but brings with it a number of problems in terms of overhead, correctness and safety.

As we saw above, the first problem is that a string is not an identifier, and therefore
must be passed as an argument to some function or method to actually return
 an object, either doubling (function+
identifier) or tripling (class/object + message + string ) the number of entities involved to 
retrieve the desired entity.  

The compiler does not have insight into strings that may be used as user-level 
identifiers at some point in the future, and therefore cannot determine wether 
a string-based identifier is correct, or even syntactically well-formed.   The compiler
and runtime also cannot help with turning the identifier into a more efficient representation
like an index into a local store.  Instead, lookup must be performed using hash-tables
or other dictionary structures at runtime on individual path components, 
and complex paths must be first be decomposed into their components.

All this run-time processing of strings is performed with general-purpose string
processing libraries that do not take the identifier semantics into account, with
many string operations capable of turning valid identifiers into invalid ones.
While it was fairly easy to paper over the differences between strings as 
data structures for human-readable text and strings as identifiers for programs,
the differences are becoming more obvious with internationalization, as the
problems making Perl UTF8 or Unicode aware demonstrate \cite{perl-unicode}

Mixing strings-as-user-data with strings-as-identifiers also has well known
security problems such as shell-escaping and SQL-injection, one of the
biggest sources of vulnerabilities on the web.



\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
u := NSURL alloc
           initWithScheme:'http'
           host:'www.example.org'
           path:'/' 
\end{verbatim}
\caption{URL initialized in an object-oriented fashion}
\label{url-as-obj}
\end{center}
\end{figure}

On the other hand, using non-string types, while increasing safety somewhat,
obscures intent further by breaking up the identifiers.
It is certainly debatable wether the more object-oriented
initialization of Figure~\ref{url-as-obj}  has any practical benefits over a
simple initialization from string as in Figure~\ref{url-as-string}, and in
the end the components are still strings and must be converted/combined
into the full URL at runtime.


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
u:=NSURL URLWithString:'http://www.example.org'
\end{verbatim}
\caption{URL initialized with a single string}
\label{url-as-string}
\end{center}
\end{figure}





\section{Polymorphic Identifiers}
\epigraph{A change in perspective is worth 80 IQ points}{Alan Kay}

Syntactically, Polymorphic Identifiers are URIs \cite{rfc3986}, so external resources
such as web pages or files can be addressed directly in an identifier-oblivious
style.  The examples in Figure~\ref{first-polymorphic-examples} show a plain
identifier that will retrieve the ACM's home page, an assignment that will read
the contents of a file into a local variable and finally an assignment that will
write the contents of the local variable to a file, effecting a file copy operation.


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
http://www.acm.org/
joesBashrc := file:/Users/joe/.bashrc
file:/Users/mike/.bashrc := joesBashrc
\end{verbatim}
\caption{Polymorphic Identifiers in simple expressions}
\label{first-polymorphic-examples}
\end{center}
\end{figure}

\subsection{Schemes}

The scheme name part of the identifier symbolically designates the handler object which 
is used to resolve the remainder of the identifier.   A user-extensible class hierarchy of
scheme resolvers handle 
return bindings that map to actual objects. The scheme resolvers are made available to the 
language by associating them with a scheme name in the special {\bf scheme} scheme,
as shown in Figure~\ref{scheme-scheme-http}. 

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
scheme:http := URLSchemeResolver scheme.
scheme:file := FileSchemeResolver scheme.
\end{verbatim}
\caption{Adding the http scheme}
\label{scheme-scheme-http}
\end{center}
\end{figure}

The scheme scheme can also be queried,
so the expression {\bf scheme:http} returns the currently installed http handler, and 
{\bf scheme:scheme} returns the scheme scheme, allowing the installed schemes to
be listed.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
scheme:scheme
    file, ftp, default, var, bundle, defaults, 
    sel, mainbundle, app, scheme, http,
    env, ref, class,  https
\end{verbatim}
\caption{List of schemes via scheme:scheme}
\label{scheme-scheme}
\end{center}
\end{figure}

\subsection{In-memory access}

The {\bf var} scheme refers to in-memory variables, so {\bf var:anObject} references the
local variable {\bf anObject}.   Compound paths can be given and are resolved in
cooperation with the object, usually by sending unary messages.

The {\bf default} scheme 
is a special scheme that is substituted when a scheme is not otherwise provided.
With the {\bf default} scheme set to the {\bf var} scheme, the {\bf var:} can be 
dropped and we can refer to the local {\bf anObject} variable just by its name.
However, the default scheme can be set to some other scheme if that is more
convenient for the task at hand, as shown in Figure~\ref{file-as-default-scheme},
where a file copy is performed after the default scheme is set to file.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
scheme:default := scheme:file
myBashRc := .basrhc
\end{verbatim}
\caption{File copy with file: as default scheme}
\label{file-as-default-scheme}
\end{center}
\end{figure}

One syntactic limitation of the default scheme mechanism is that it does not allow
compound paths, so for compound paths a full URI with scheme must be used.



\subsection{First class references}

The bindings returned by scheme-resolvers are usually ephemeral, used just 
to get to the value pointed to by the identifier, either reading or writing it.  This
makes it possible to program with arbitrary and user-defined identifiers in
an identifier-oblivious style.  It also means that for sufficiently simple scheme-resolvers,
the binding can actually be elided if the compiler can determine that it is not needed.

However, as we saw earlier, it is sometimes
desirable to use the identifier-aware style.  In order to do this, the language
must provide access to the bindings used in resolving the identifier.

The {\bf ref} scheme prevents evaluation of the binding and thus allows access
to the binding itself.  

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
a := 42
b := ref:var:a.
b value  -> 42
b bindValue:2
a -> 2
\end{verbatim}
\caption{Accessing a variable via its binding}
\label{ref-binding}
\end{center}
\end{figure}

Common operations on bindings are retrieving, binding and unbinding a value and testing 
wether a binding has a value, as shown in Figure~\ref{isBound} for the {\bf env} scheme
that provides access to Unix environment variables.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
> ref:env:bozo isBound  -> 0
> env:bozo := 'hi'
> ref:env:bozo isBound  -> 1
\end{verbatim}
\caption{Is environment variable set?}
\label{isBound}
\end{center}
\end{figure}

Bindings are scheme-specific and can include additional API specific to that type of scheme.
For example, file bindings are analogues of the Java {\bf File} object and can deliver
meta-data about and perform operations on the file as shown in Figure~\ref{ref-file-dir}.

\begin{figure}[h]
\begin{center}
\begin{verbatim}
> newDir := ref:file:testDir 
> newDir isDirectory  -> 1
\end{verbatim}
\caption{File and directory manipulation}
\label{ref-file-dir}
\end{center}
\end{figure}



Bindings for remote resources include methods for initiating a transfer, cache-control,
error-checking and progress monitoring.   Bindings can be passed to user interface
elements for manipulation of the object referenced.


\subsection{Abstraction}

With richer identifiers, it makes sense to allow abstractions to be built with these identifiers.
One example is parametrization, with an identifier having parameters that are evaluated
at runtime, as seen in Figure~\ref{bashrc-pi} that retrieves the current user's {\bf .bashrc} 
and is equivalent to Figures~\ref{posix-file-resolve}, \ref{cocoa-file-contents} and 
\ref{sh-file-contents}.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
file:{env:HOME}/.bashrc
\end{verbatim}
\caption{Parametrized Identifier}
\label{bashrc-pi}
\end{center}
\end{figure}

Another example is the relative scheme resolver, which takes a base-binding
and evaluates its references relative to that base.  Figure~\ref{rfc-scheme} shows
how to use a relative scheme resolver to build a scheme that can directly
reference Internet Engineering Task Force Request For Comments (IETF RFCs).
The end effect is that we can hide the actual location and access method for
the IETF RFCs behind a scheme so we can access those RFCs directly.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
base := ref:http://datatracker.ietf.org/doc/.
scheme:rfc := RelScheme schemeWithBase:base.
uriSyntax := rfc:rfc2396.
\end{verbatim}
\caption{Retrieving RFC 2396 (URI Syntax) via custom rfc: scheme}
\label{rfc-scheme}
\end{center}
\end{figure}

A sequential composition scheme simply searches a list of other schemes
for a particular identifier.  It searches its argument schemes sequentially
for the identifier in question and returns the first match.  Lookup rules for
identifiers that are usually hard-coded into languages can be expressed
as a sequential composition scheme, for example:   \{ scheme:local ,
scheme:ivar \} for Smalltalk (ignoring globals and class



\section{Implementation}

Polymorphic Identifiers have been implemented as part of Objective-Smalltalk \cite{objst},
a Smalltalk dialect built on top of the Objective-C\cite{objc-evol}\cite{objc-apple} runtime, 
in a way that is similar to FScript\cite{fscript} and MacRuby \cite{macruby}.

Objective-C is an ahead-of-time-compiled, hybrid dynamic object oriented programming language
that is an extension of C.  The object-oriented extensions to C are closely modeled on
Smalltalk, with dynamic single-dispatch at runtime, a keyword syntax and classes as
largely first-class objects.

Objective-Smalltalk objects and classes are Objective-C objects, they are created using
the same functions and data structures and are indistinguishable at runtime.
The same goes for Objective-Smalltalk methods, which are also indistinguishable from
Objective-C methods, making Objective-Smalltalk in a sense a meta-circular language
that is written in itself, or more precisely written in variants of itself \cite{kleinvm}\cite{squeak}.

Figures~\ref{get-env}-\ref{setvalue-env} show the implementation of a simple scheme,
the env-scheme that provides access to Unix environment variables.  Figure~\ref{get-env}
shows the {\bf bindingForName:inContext:} method that is the main access point for
converting from an identifier to a binding.  In this case, a generic binding object is returned
that simply stores the name of the identifier and lets the scheme that created it resolve
access via the {\bf valueForBinding:} and {\bf setValue:forBinding:} methods.



\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
-(const char*)cstringValueOfBinding:aBinding
{
  return getenv([[aBinding name] UTF8String]);
}

-bindingForName:aName inContext:aContext
{
  return [GenericBinding bindingWithName:aName scheme:self];
}

-valueForBinding:aBinding
{
  const char *val=[self cstringValueOfBinding:aBinding];
  if ( val ) {
    return [NSString stringWithUTF8String:val];
  } else {
    return nil;
  }
}
\end{verbatim}
\caption{Basic lookup in env-scheme}
\label{get-env}
\end{center}
\end{figure}

In this case, the name of the identifier is simply passed to the POSIX {\bf getenv()} function.
Setting the value is handled in an analog fashion using the {\bf setenv()} function.



\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
-(void)setValue:val forBinding:binding
{
  val=[newValue stringValue];
  if ( val  ) {
    setenv([[binding name] UTF8String],[value UTF8String],1);
  } else {
    unsetenv([[binding name] UTF8String]);
  }
}
\end{verbatim}
\caption{Set value in env-scheme}
\label{setvalue-env}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
-(BOOL)isBoundBinding:aBinding
{
  return [self cstringValueOfBinding:aBinding] != NULL;
}
\end{verbatim}
\caption{Checking for presence of value in env-scheme}
\label{hasValue-env}
\end{center}
\end{figure}



\section{Discussion}



\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
base := ref:file:{env:HOME}.
scheme:home := RelScheme schemeWithBase:base.
home:.bashrc.
\end{verbatim}
\caption{Accessing .bashrc via custom home: scheme}
\label{rfc-scheme}
\end{center}
\end{figure}




\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
 host := 'citeseerx.ist.psu.edu'.
 viewCiteSeer:=ref:http://{host}/viewdoc/summary
 viewCiteSeer getWithArgs doi:'10.1.1.41.7628'
\end{verbatim}
\caption{URL arguments via reference and higher order message}
\label{url-args}
\end{center}
\end{figure}




\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
tell application "iTunes"
  set trackname to name of current track
end tell
tell application "iChat"
  set status message to trackname
end tell
\end{verbatim}
\caption{Using AppleScript to set chat status from track name}
\label{AppleScript}
\end{center}
\end{figure}


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
app:iChat/statusMessage :=
                app:iTunes/currentTrack/name
\end{verbatim}
\caption{Access to applications via polymorphic identifiers}
\label{NonAppleScript}
\end{center}
\end{figure}


\section{Related Work}


\subsection{Path-based access in languages}

Programming languages such as C, C++ or Pascal have facilities for composite
identifiers, for example using the dot or {\bf -> } operators, but these facilities allow
direct access to the internal data, without any ability of the structure in question to 
mediate, as does handing out pointers to internal parts.

Properties in C\# and Objective-C 2.0 allow a variable-access interface to be backed by 
message sending, thus allowing path-based access under dynamic control of the object
in question, but without having first-class references or the ability to access other
types of resources using the same mechanism.

ThingLab\cite{thinglab}  adds path-based access to the base Smalltalk language in order to support
constraints referencing parts of objects, say the vertex of a triangle, and these
references do exist as first class objects that can be passed to other objects.
   It does not
expand this path-based access to other domains or make it user-extensible.

\subsection{Unified path-based access mechanisms}


User level filesystems like FUSE\cite{fuse} or the BSD Pass-to-User-Space\cite{puffs} 
system allow
user-level code to add new filesystems to the Unix kernel, without requiring
kernel modifications or impacting operating system kernel stability.

This approach allows many sorts of local and remote data-types to be 
treated as files in a filesystem and made available to the wide variety
of Unix tools that can navigate and process such files.  

However, this support requires global installation of handlers in the operating
system, which also must mediate access, making integration of in-memory 
variables difficult at best.  The identifiers used to access these resources
are also still strings that are not integrated with the identifier mechanism of
the host language, with all the problems discussed in Section~\ref{stringtrouble}.

Using FUSE/puffs filesystems as scheme resolvers without kernel intervention seems
like a useful addition, as is making scheme-resolvers available to the Unix kernel
via FUSE/puffs.

The Plan9\cite{plan9names}\cite{plan9network} operating system from Bell Labs goes further than FUSE in integrating
all data, local and network resources into a single hierarchical namespace.  Similar
caveats as for FUSE apply.

Phantom XML\cite{phantomxml} unifies access to data by treating all data as
XML trees, allowing queries against this XML representation of the data without
actually converting it to XML first.  




\subsection{URIs in E}

The E language\cite{MillerRobustComposition}  supports URI-Expressions such as
the  {\bf <file:c:/jabbertest>} or {\bf <http://www.erights.org>}.  However,
it only supports using them in the reference-aware style and does not integrate 
ordinary identifiers into the URI mechanism, provide abstraction mechanisms
for URIs or an extension mechanism. 


\subsection{References in Icon}

In the Icon programming language \cite{IconRef} , identifiers (references) can be first class values,
and there are complex rules for when a reference remains a reference and when
it's value is used.  However, the rules are implicit and there is no way for the 
developer to choose when to be identifier-aware or identifier-oblivious.  Furthermore,
there is no way for the user to extend the language with new types of references 
or behaviors.



\subsection{Domain Specific Languages}

Polymorphic Identifiers are an attempt to achieve at least some of the benefits
of Domain Specific Languages without many of the costs.  They provide a
pluggable mechanism that makes it possible to generate variations, subclasses
in effect, of programming languages, rather than having to create entirely new languages
from scratch.

Using a common, yet extensible syntax for identifiers with varying semantics means
that one set of syntactic tooling suffices and programs have a better chance of
remaining readable despite the variation in the language.


\subsection{Proxies,Mirrors and Mirages}

Smalltalk reflective facilities \cite{reflective-st} have long been used to build
facilities such as distributed object systems, futures, lazy evaluation and
transparent storage mechanisms.  One problem with the Smalltalk facilities
has been that they are defined in an ad-hoc fashion from error handling routines
and not sufficiently stratified, with meta-level functions
interfering with base-level functions and vice-versa.  Another problem is that
most reflective techniques only apply to messages, not to identifiers, making 
those techniques unavailable.

Mirrors \cite{mirrors} and Mirages \cite{mirages} improve the stratification and
reflection/intercession capabilities, but are not capable of dealing with pure
identifiers or of bringing user-defined resource handlers into the language.

The proposed ECMAScript Proxy mechanism \cite{VanCutsemMiller} addresses
the stratification issues and also integrates some identifier access into the 
metaprogramming framework, but doesn't allow user-extensible identifiers.

We believe that mechanisms such as remote objects, futures, proxies and the like
are actually properly modeled not at the object level, but at the identifier/reference
level, so that a significant part of what is currently considered metaprogramming
becomes programming at the identifier level.

\subsection{Internet Programming Languages and Systems}

The success of the REST architectural style\cite{fielding-rest} on the web has sparked
systems and languages that try to more directly model and take advantage of that
style.

The Wheat language \cite{wheat} embedded an entire programming language
and system into a web-server, accessing all resources and methods via
HTTP URLs.  Polymorphic Identifiers allow resources, but these resources
are not required to use a specific communications mechanism.


Resource Oriented Computing \cite{roc} goes even further by
requiring all computation to be expressed through URIs, adding Active URIs
for computation as shown in Figure~\ref{activeuri}


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
active:{base}+{name}@{uri}...
\end{verbatim}
\caption{Active URI}
\label{activeuri}
\end{center}
\end{figure}

The {\bf base} is a function name, the {\bf name} an argument name and the
{\bf uri} an argument URI.
 While Polymorphic Identifiers allow processing to be
hidden behind a resource URI, they also allow messaging to be expressed
as messaging when that is the intent.



\section{Summary and Outlook}

Introduced user-extensible identifiers based on URL syntax and 
integrated them as a fundamental part of a programming language
as the sole identifier lookup/evaluation system.



%\appendix
%\section{Appendix A}

%This is the text of the appendix, if you need one.

%\acks

%Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrv}

% The bibliography should be embedded for final submission.
\bibliography{polymorphic-identifiers}

\balancecolumns
\end{document}
