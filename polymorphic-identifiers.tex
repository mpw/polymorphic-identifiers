%-----------------------------------------------------------------------------
%
%    Domain Specific Identifiers
%
%-----------------------------------------------------------------------------


\documentclass[preprint,authoryear,10pt]{sigplanconf}


\usepackage{amsmath}
\usepackage{epigraph}
\usepackage[colorlinks=true,
        linkcolor=black,
        citecolor=black,
        filecolor=black,
        pagecolor=black,
        urlcolor=black,
        bookmarks=true,
        bookmarksopen=true,
        bookmarksopenlevel=3,
        plainpages=false,
        pdfpagelabels=true]{hyperref}

\begin{document}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2011} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Polymorphics Identifiers}
%\subtitle{Subtitle Text, if any}

\authorinfo{Marcel Weiher}
           {metaobject ltd.}
           {marcel@metaobject.com}
\authorinfo{Robert Hirschfled}
           {Hasso Plattner Institut}
           {hirschfeld@acm.org}

\maketitle

\begin{abstract}
We introduce polymorphic identifiers, a generalization of the monomorphic identifiers found in most
programming languages today as first class objects, as well as mechanisms for
resolving those identifiers and binding them into a general purpose programming language.
These identifiers allow stratified designs clearly separating meta- and base-level constructs
as well as light-weight domain-specificity with high levels of expressiveness, 
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms 
\keywords
\setlength{\epigraphrule}{0pt}


\section{Introduction}
\epigraph{There are only two hard things in Computer Science:  cache invalidation and naming things} {Phil Karlton}

This is not a paper about cache invalidation.  Mostly.   Rather, we report on an experimental
technique for expanding our ability to directly name many different things in 
programming languages using a common and extensible identifier and identifier resolution
mechanisms.
These polymorphic identifiers are not just user-extensible,
but can also be manipulated in the programming language, making them first class 
entities.

Our starting point is a programming model such as that of Smalltalk, where we have objects
that communicate via messages\cite{Goldberg1983}.   Identifiers are used to identify 
objects, but are early bound by the compiler and resolved to slots in local contexts, and 
global, instance-, class- or pool-variables.  Late-binding of names, encapsulation and
polymorphic behavior can only be achieved with message sends.

We then give various examples both of additional things that one might want to reference 
 apart from objects resident in a single address space  and
desirable operations on identifiers beyond resolving them to objects at compile time.

We believe that the accidental complexity \cite{Brooks87nosilver} introduced by the
plethora of ad-hoc mechanisms for addressing these desiderata can be reduced 
by unifying them using the polymorphic identifiers introduced in this paper.


\section{Identifiers}


Identifiers are text strings that serve as human-readable names for entities/objects
in a program.  They are converted to actual references, usually with a mixture of
compile-time and run-time lookups.  For example, to obtain the value of the local
variable named {\bf anObject}, one would have to search the local context for
a slot named {\bf 'anObject'} and then return the value stored at that slot.


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
(localContext variableNamed:'’anObject’') value.
\end{verbatim}
\caption{Lookup of a local variable}
\label{hi1}
\end{center}
\end{figure}


Some  languages actually perform all these steps at runtime, but most 
have a compiler help with efficiency by converting the names to indexes into
the local context and the value lookup into a simple load from memory.

Most programming languages don't just optimize the interface to the identifier
lookup operation, but also the interface.  Instead of having to specify how to
look up the identifier in the local context, the programmer can just write the
identifier {\bf anObject}, which the programming language will treat as equivalent to the
value that will be obtained by looking up the name in the local context.  


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	anObject.
\end{verbatim}
\caption{Identifer-oblivious variable lookup}
\label{bozo}
\end{center}
\end{figure}

This  {\em identifier-oblivious} style, where lookup of the value bound to and
identifier is implied, is so familiar that we don't usually think about it.  The 
alternative {\em identifier-aware} style shown in Figure~\ref{hi1} would get cumbersome quickly!



\begin{itemize}
\item Early bound
\item Polymorphism only via messaging, interface/API only via messaging, this mixes 
	interface with implementation and 
\item 
\end{itemize}


\subsection{Interface vs. Implementation}

Smalltalk:  have to use messaging for interface/polymorphism.

\subsection{External Resources}

Files/Paths, URLs, Distributed Objects, messaging hiding behind identifier access

\subsection{Complex Identifiers}

\subsection{Manipulating Identifiers}


\subsection{Identifier Awareness}



\subsection{The Trouble with Strings}

\epigraph{The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.}{Alan Perlis}


\epigraph{Trying to outsmart a compiler defeats much of the purpose of using one.}{Kernighan and Plauger, The Elements of Programming Style.}



\begin{itemize}

\item Processing the representation, details obscure intent
\item Mixing data and identifiers
\item Internationalization makes things (much) worse
\item Security, quoting, (SQL)-injection attacks

\end{itemize}

\section{Polymorphic Identifiers}


\section{Examples}

\section{Implementation}



Existing mechanisms for variable access via built-in identifiers not adequate in 
all domains, for example:
 \begin{itemize}

\item path-based access to various in-memory data structures (e.g. DOMs)
\item GUIs, serialization and notification mechanisms require treating a variable
	reference as a parameter.
\item external resources such as files and the web

\end{itemize}

Although these problems seem to be different from each other, we argue that they
have the same underlying cause:   lack of a first class identifiers.  

Coping mechanisms:  
\begin{itemize}
\item access to 'things' via messages rather than directly via identifiers.  
\item identifiers encoded as strings in the programming language
\item introduction of separate objects that act like identifiers
\item use of DSLs
\end{itemize}


\section{Related Work}

\subsection{LISP Quoting}

LISP quoting allows references to not be evaluated, but the returned value is just a symbol.

\subsection{E}

The E language adds URL for far references and some stuff

\subsection{ThingLab}

Paths in ThingLab were necessary in order to specify subparts of objects and allow them
to be referenced.

\subsection{. references}



\subsection{Properties}

Properties in C\# and Objective-C 2.0 allow a variable-access interface to be backed by 
message sending, thus allowing path-based access 

\subsection{Icon}

In the Icon programming language, identifiers (references) can be first class values,
and there are complex rules for when a reference remains a reference and when
it's value is used.


\section{Summary and Outlook}



\appendix
\section{Appendix A}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
\bibliography{polymorphic-identifiers}


\end{document}
