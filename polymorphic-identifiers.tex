%-----------------------------------------------------------------------------
%
%    Domain Specific Identifiers
%
%-----------------------------------------------------------------------------


\documentclass[preprint,authoryear,10pt]{sigplanconf}


\usepackage{amsmath}
\usepackage{epigraph}
\usepackage[colorlinks=true,
        linkcolor=black,
        citecolor=black,
        filecolor=black,
        pagecolor=black,
        urlcolor=black,
        bookmarks=true,
        bookmarksopen=true,
        bookmarksopenlevel=3,
        plainpages=false,
        pdfpagelabels=true]{hyperref}

\begin{document}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2011} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Polymorphic Identifiers}
%\subtitle{Subtitle Text, if any}

\authorinfo{Marcel Weiher}
           {metaobject ltd.}
           {marcel@metaobject.com}
\authorinfo{Robert Hirschfled}
           {Hasso Plattner Institut}
           {hirschfeld@acm.org}

\maketitle

\begin{abstract}
We introduce polymorphic identifiers, a generalization of the monomorphic identifiers found in most
programming languages today as first class objects, as well as mechanisms for
resolving those identifiers and binding them into a general purpose programming language.
These identifiers allow stratified designs clearly separating meta- and base-level constructs
as well as light-weight domain-specificity with high levels of expressiveness, 
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms 
\keywords
\setlength{\epigraphrule}{0pt}


\section{Introduction}
\epigraph{There are only two hard things in Computer Science:  cache invalidation and naming things} {Phil Karlton}

This is not a paper about cache invalidation.  Mostly.   Rather, we report on an experimental
technique for expanding our ability to directly name many different things in 
programming languages using a common and extensible identifier and identifier resolution
mechanism.
These polymorphic identifiers are not just user-extensible,
but can also be manipulated in the programming language, making them first class 
entities.

Our starting point is a programming model such as that of Smalltalk, where we have objects
that communicate via messages\cite{Goldberg1983}.   Identifiers are used to identify 
objects, but are early bound by the compiler and resolved to slots in local contexts, and 
global, instance-, class- or pool-variables.  Late-binding of names, encapsulation and
polymorphic behavior can only be achieved with message sends.

We then give various examples both of additional things that one might want to reference 
 apart from objects resident in a single address space  and
desirable operations on identifiers beyond resolving them to objects at compile time.

We believe that the accidental complexity \cite{Brooks87nosilver} introduced by the
plethora of ad-hoc mechanisms for addressing these desiderata can be reduced 
by unifying them using the polymorphic identifiers introduced in this paper.


\section{Identifiers}
\label{identifiers}
\epigraph{When programming a component, the right computation model for the component is the least expressive model that results in a natural program.}{Rule of Least Expressiveness.}

Identifiers are symbols that serve as human-readable names for entities/objects
in a program.  They are converted to actual references, usually with a mixture of
compile-time and run-time lookups.  For example, to obtain the value of the local
variable named {\bf anObject}, one would have to search the local context for
a slot named {\bf 'anObject'} and then return the value stored at that slot.


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
(localContext variableNamed:'ÕanObjectÕ') value.
\end{verbatim}
\caption{Lookup of a local variable}
\label{variable-lookup}
\end{center}
\end{figure}


Some  languages actually perform all these steps at runtime, but most 
have a compiler help with efficiency by converting the names to indexes into
the local context and the value lookup into a simple load from memory.

Most programming languages don't just optimize the implementation of the identifier
lookup operation, but also the interface.  Instead of having to specify how to
look up the identifier in the local context, the programmer can just write the
identifier {\bf anObject}, which the programming language will treat as equivalent to the
value that will be obtained by looking up the name in the local context.  


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	anObject.
\end{verbatim}
\caption{Identifer-oblivious variable lookup}
\label{plain-identifier}
\end{center}
\end{figure}

This  {\em identifier-oblivious} style shown in Figure~\ref{plain-identifier}, where lookup of the value bound to and
identifier is implied, is so familiar that we don't usually think about it, we just
refer to object using the identifier.
  The 
alternative {\em identifier-aware} style shown in Figure~\ref{variable-lookup} would get cumbersome quickly.

Non-local entities such as sub-parts of constructed objects 
cannot be referred to symbolically by a single identifier.
Instead, they must be obtained using computation, a 
sequence of operations, which in Smalltalk is performed using message sends.
For example, assuming we have a model of a robot, we might obtain the
color of the robot's left eye as follows:

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	robot head leftEye color.
\end{verbatim}
\caption{Obtaining a reference via chained message sends}
\label{non-local-reference}
\end{center}
\end{figure}


Although we can hide an object reference behind a computational interface, we cannot
hide a computation behind a object reference interface.
Thus any kind of external API has to be presented through a computational, messaging 
interface, even if the intention is not computation, but just access to a resource,
  and all information hiding also requires messaging.  This has led languages
like Self \cite{UngarS87} and Newspeak \cite{newspeak} to effectively abandon identifiers as symbolic names for objects, 
all objects are instead obtained by sending messages to other objects.

On the World Wide Web with its REST architectural model the situation is exactly the reverse: 
 the interface
to resources is their identifier, the Uniform Resource Locator (URL).   Wether
computation happens in providing the resource is a hidden implementation detail
(ignoring the messaging protocols usually required to transmit the resource
to the client).  


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
http://www.shipper.com/track/12345678
\end{verbatim}
\caption{A Uniform Resource Locator}
\label{url-example}
\end{center}
\end{figure}

So instead of having
a package-tracking application that takes a parameter (2 entities),
one can simply take the view that ``every package has its own 
web-site'', which is then just one entity referenced by a single,
parameterless identifier.  Instead of hiding references behind messaging,
messaging is hidden behind an identifier, and RESTful web applications
perform computations by dereferencing a series of identifiers, that 
are provided incrementally and dynamically in responses.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
urn:isbn:123123123
\end{verbatim}
\caption{URN}
\label{urn-example}
\end{center}
\end{figure}

Whereas URLs specify an access path, including a network protocol, Uniform 
Resource Names like the ISBN in Figure~\ref{urn-example} just specify a logical
name, leaving the resolution of that name completely open.  In a sense, URNs
correspond to interfaces 

Uniform Resource Identifiers are a generalization of both Uniform Resource Locators
and Uniform Resource Names.  

URIs are a generalization of Uniform Resource Locators, which specify a
resource by its network location and access path and Uniform Resource Names,
which specify
a resource by a logical name and leave it to system processes to 
determine the exact location.  In practice, most URIs are located on
a continuum with URNs on one end and URLs on the other.

\section{User-level identifiers}


In addition to the entities that can be referred to directly by the programming language's 
built-in identifiers, there are many other entities and situations where that is not possible.
However, entities still need to be addressed, so developers are required
to construct their own identifiers or references and methods for resolving them to the actual
entities.

\subsection{External Resources}

Files, for example are referenced by their filename, or more precisely
a string that represents their access path in the filesystem from the root 
directory.   The operating system is responsible for mapping these full
paths to entities allowing access to the contents of the file.  For example accesing
the current user's ``.bashrc'' file looks as follow:

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
   char fullname[MAXPATHLEN];
   snprintf(fullname,MAXPATHLEN,"%s/.bashrc",
                            getenv("HOME"));
   int fd = open( filename );
   if ( fd >= 0 ) { 
      //... read contents of file using read()
      close(fd);
   }
\end{verbatim}
\caption{Resolving a name in the user's home directory to a file}
\label{posix-file-resolve}
\end{center}
\end{figure}

The string represents a user-level identifier, which is just a plain character
string that has no meaning to the programming language and must be 
manually resolved by the developer in the {\em identifier-aware} style 
introduced in Section~\ref{identifiers}.  In fact, two different identifiers
are resolved in Figure~\ref{posix-file-resolve}:  first, the identifier {\bf HOME}
from the domain of environment variables is needed, which requires calling
the {\bf getenv()} function to resolve the identifier string to a value.  That result,
also a string, is then combined with the name of the file in question and passed
to the {\bf open()} system call to return an actual file reference.  Boundary conditions
and error checking have largely been elided.

Convenience APIs can ameliorate the situation somewhat, for example shortening 
the multiple steps above into a single (slightly verbose) expression and making the
string processing safer.  However, they cannot
change the fundamental fact that the identifiers in question are basic strings,
manipulating them requires string processing and user-level resolution of the
string to an entity.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
   NSData dataWithContentsOfFile:
     ((NSProcessInfo processInfo
        environment 
        objectForKey:'HOME') 
       stringByAppendingPathComponent:'.bashrc')

\end{verbatim}
\caption{Cocoa convenience API for accessing file content}
\label{cocoa-file-contents}
\end{center}
\end{figure}


Which identifiers we can use in an oblivious style and which we need to
be aware of and resolve ourselves is pre-determined by the programming
language.
The same identifier that needs to be created using string processing from various
components in both the POSIX and the Cocoa can be written directly in a typical
Unix shell, including the variable part.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	cat $HOME/.basrhc
\end{verbatim}
\caption{File contents in a shell}
\label{sh-file-contents}
\end{center}
\end{figure}

The lack of string quotes is not just cosmetic: both the variable and the filename
are not just opaque strings, but entities that the shell is aware of and can identify
using the identifiers provided,for example being able to assist by autocomplete 
or wildcard expansion.



\subsection{Dynamic data structures}

Path-based access is not restricted to external resources, but also
prevalent when accessing dynamic data structures

 such as an XML DOM (xpath)

\begin{itemize}
\item [mpw] more details
\end{itemize}

\subsection{User Interfaces}




\subsection{Network Resources}



\subsection{The Trouble with Strings}

\epigraph{The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.}{Alan Perlis}


One aspect that virtually all user-level identifier mechanisms have in common is that they
are based on string processing.  The use of strings makes user-level identifiers relatively
close to language identifiers ({\bf \hbox{anObject}} vs {\bf \hbox{'anObject'}}), but brings with it a number of problems in terms of overhead, correctness and safety.

As we saw above, the first problem is that a string is not an identifier, and therefore
must be passed as an argument to some function or method to actually return
 an object, either doubling (function+
identifier) or tripling (class/object + message + string ) the number of entities involved to 
retrieve the desired entity.  

The compiler does not have insight into strings that may be used as user-level 
identifiers at some point in the future, and therefore cannot determine wether 
a string-based identifier is correct, or even syntactically well-formed.   The compiler
and runtime also cannot help with turning the identifier into a more efficient representation
like an index into a local store.  Instead, lookup must be performed using hash-tables
or other dictionary structures at runtime on individual path components, 
and complex paths must be first be decomposed into their components.

All this run-time processing of strings is performed with general-purpose string
processing libraries that do not take the identifier semantics into account, with
many string operations capable of turning valid identifiers into invalid ones.
While it was fairly easy to paper over the differences between strings as 
data structures for human-readable text and strings as identifiers for programs,
the differences are becoming more obvious with internationalization, as the
problems making Perl UTF8 or Unicode aware demonstrate \cite{perl-unicode}

Mixing strings-as-use-data with strings-as-identifiers also has well known
security problems such as shell-escaping and SQL-injection, one of the
biggest sources of vulnerabilities on the web.



\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
u := NSURL alloc
           initWithScheme:'http'
           host:'www.example.org'
           path:'/' 
\end{verbatim}
\caption{URL initialized in an object-oriented fashion}
\label{url-as-obj}
\end{center}
\end{figure}

On the other hand, using non-string types, while increasing safety somewhat,
obscures intent further by breaking up the identifiers.
It is certainly debatable wether the more object-oriented
initialization of Figure~\ref{url-as-obj}  has any practical benefits over a
simple initialization from string as in Figure~\ref{url-as-string}.


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
u := NSURL URLWithString:'http://www.example.org'
\end{verbatim}
\caption{URL initialized with a single string}
\label{url-as-string}
\end{center}
\end{figure}





\section{Polymorphic Identifiers}
\epigraph{A change in perspective is worth 80 IQ points}{Alan Kay}



\begin{itemize}
\item encapsulate processing required for user-extensible identifiers / resource access
\item oblivious or aware not dependent on type of reference
\item runtime or compile-time not dependent on type of reference
\item computational or referential interface at will 
\item ability to 

\end{itemize}


\begin{itemize}


\item URL syntax
\item User-level scheme resolvers
\item Mix of run-time / compile-time evaluation (can be fully runtime) without forcing
\item scheme:scheme to make resolvers part of the language and allow identifier-oblivious
	programming for user-defined identifiers
\item ref: allows access to identifiers in order to make any reference identifier-aware
\item Semantics-preserving operations on identifiers \{\} , relative schemes, composite schemes

\end{itemize}


\section{Examples}

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
 host := 'citeseerx.ist.psu.edu'.
 citeseer:=ref:http://{host}/viewdoc/summary
 citeseer getWithArgs doi:'10.1.1.41.7628'
\end{verbatim}
\caption{URL arguments via reference and higher order message}
\label{url-args}
\end{center}
\end{figure}




\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
tell application "iTunes"
  set trackname to name of current track
end tell
tell application "iChat"
  set status message to trackname
end tell

app:iChat/statusMessage := app:iTunes/currentTrack/name
\end{verbatim}
\caption{Access to applications}
\label{url-args}
\end{center}
\end{figure}


(aus:  http://developer.apple.com/cocoa/applescriptforapps.html)


Mit Arches:


\section{Implementation}



Coping mechanisms:  
\begin{itemize}
\item introduction of separate objects that act like identifiers
\end{itemize}


\section{Related Work}

\subsection{LISP Quoting}

LISP quoting allows references to not be evaluated, but the returned value is just a symbol.

\subsection{E}

The E language adds URL for far references and some stuff

\subsection{Domain Specific Languages}


\subsection{ThingLab}

ThingLab adds path-based access to the base Smalltalk language in order to support
constraints referencing parts of objects, say the vertex of a triangle.   It does not
expand this path-based access to other domains or make it user-extensible.

\subsection{. references}



\subsection{Properties}

Properties in C\# and Objective-C 2.0 allow a variable-access interface to be backed by 
message sending, thus allowing path-based access 

\subsection{Icon}

In the Icon programming language, identifiers (references) can be first class values,
and there are complex rules for when a reference remains a reference and when
it's value is used.

\subsection{Resource Oriented Programming}

\subsection{ValueHolder objects}

\subsection{Key Value Coding, Observing, Binding}

\subsection{User Level File Systems}

For example, FUSE  \cite{fuse}

\subsection{Internet Programming Languages and Systems}

What \cite{wheat}, Web-Machine, Presto, 

\section{Summary and Outlook}



%\appendix
%\section{Appendix A}

%This is the text of the appendix, if you need one.

%\acks

%Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
\bibliography{polymorphic-identifiers}


\end{document}
