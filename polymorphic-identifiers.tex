%-----------------------------------------------------------------------------
%
%    Domain Specific Identifiers
%
%-----------------------------------------------------------------------------


\documentclass[preprint,authoryear]{acm_proc_article-sp}

\usepackage{ifthen}

\usepackage{amsmath}
\usepackage{epigraph}
\usepackage[colorlinks=true,
        linkcolor=blue,
        citecolor=red,
        filecolor=black,
        pagecolor=black,
        urlcolor=black,
        bookmarks=true,
        bookmarksopen=true,
        bookmarksopenlevel=3,
        plainpages=false,
        pdfpagelabels=true]{hyperref}

%%--- listings configuration
\usepackage{listings}
\lstset{
  language={C},
  basicstyle=\ttfamily,
  keywordstyle=\bfseries,
  showstringspaces=false,
  commentstyle=,
  captionpos=below%,
%  numbers=left,
%  numberstyle=\tiny,
%  numbersep=5pt
}
%\lstdefinestyle{L}{basicstyle=\ttfamily}
\lstdefinestyle{L}{basicstyle=\ttfamily\scriptsize}
%%--- end of listings configuration



\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
  {\newcommand{\mynote}[2]{
      {\color{red}
    \fbox{\bfseries\sffamily\scriptsize#1}
       {\small$\blacktriangleright$\textsf{\emph{#2}}$\blacktriangleleft$}
    % \marginpar{\fbox{\bfseries\sffamily#1}}
        }
   }
   \newcommand{\cvsversion}{\emph{\scriptsize $ $Revision: 1.42 $ $ -- $ $Date: 2005/10/01 00:23:32 $ $ }}
  }
  {\newcommand{\mynote}[2]{}
   \newcommand{\cvsversion}{}
  }

\newcommand{\here}{\mynote{***}{CONTINUE HERE}}
\newcommand\nb[1]{\mynote{NB}{#1}}
\newcommand\fix[1]{\mynote{FIX}{#1}}
% \newcommand\todo[1]{\mynote{TO DO}{#1}}
\newcommand\mpw[1]{\mynote{Marcel}{#1}}
\newcommand\rh[1]{\mynote{Robert}{#1}}


\begin{document}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2011} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.


\title{Polymorphic Identifiers}
%\subtitle{Subtitle Text, if any}

\numberofauthors{2}
\author{
\alignauthor Marcel Weiher\\
       \affaddr{metaobject ltd.}\\
       \email{marcel@metaobject.com}
}

\maketitle

\begin{abstract}
We present an experimental technique for replacing built-in identifier lookup mechanisms
of programming languages with a method for allowing user-defined identifier lookup schemes
to be bound into a base language as first class entities.  


\end{abstract}

\category{D.3.3}{Programming Languages}{Language Constructs and Features}

\terms{language, design}
\keywords{polymorphic identifiers} % NOT required for Proceedings
\setlength{\epigraphrule}{0pt}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Introduction}
%\epigraph{There are only two hard things in Computer Science:  cache invalidation and naming things} {Phil Karlton}

%This is not a paper about cache invalidation.   Rather, 
We report on an experimental
technique for expanding our ability to directly name many different 
entities
%\footnote{``Entities'' in this context are just ``things'', they are not intended to be identical
%to the entities in entity-relationship modeling} 
in programming languages using a common and extensible identifier and identifier resolution
mechanism.
These \emph{polymorphic identifiers} are not only user-extensible,
but can also be manipulated in the programming language, making them first class 
entities.

Our starting point is a programming model such as that of Smalltalk, where we have objects
that communicate via messages\cite{Goldberg1983}.   Identifiers are used to identify 
objects, but are early bound by the compiler.  Late-binding of names, encapsulation,
and polymorphic behavior can only be achieved with message-sends.


Identifiers that need to point to other entities or used in different ways must be defined
by the user and cannot be used interchangeably with built in identifiers.  

%\cite{Brooks87nosilver}
We believe that the accidental complexity introduced by the
plethora of ad-hoc mechanisms for addressing the difference between built-in 
and user-defined identifiers can be reduced 
by unifying them using our \emph{polymorphic identifiers} presented in this paper.

The contributions of this paper are (1) a classification of identifier usage styles, {\em oblivious}
and {\em aware}, which
are usually tightly coupled to identifier types, built-in and user-defined respectively.
(2) A new, URI-based identifier type
that unifies identifier types and eliminates the coupling to usage styles. (3) Mechanisms
that allow new identifier-based abstractions to be created.


The remainder of this paper is organized as follows: 
Section~\ref{background}  shows how we got to thinking about identifiers.
Section~\ref{identifiers} gives an overview on common identifier schemes.
Section~\ref{user-defined-identifiers} describes the use and shortcomings of user-defined identifiers.
In Section~\ref{polymorphic-identifiers} we present \emph{polymorphic identifiers} and briefly describe their implementation in Section~\ref{implementation}.
Section~\ref{related-work} discusses related work and Section~\ref{summary-and-outlook} concludes our paper and lays out ideas for future work.



%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Background and Motivation}
\label{background}

\begin{itemize}
\item take the three/four ideas from my notebook
\item In architecture and in languages you
\end{itemize} 




\section{Identifiers}
\label{identifiers}
%\epigraph{When programming a component, the right computation model for the component is the least expressive model that results in a natural program.}{Rule of Least Expressiveness.}

Identifiers are symbols that serve as human-readable names for entities/objects
in a program.  They are converted to actual references, usually with a mixture of
compile-time and run-time lookups.  For example, to obtain the value of the local
variable named {\bf anObject}, we would have to search the local context for
a slot named {\bf 'anObject'} and then return the value stored in that slot (Listing~\ref{variable-lookup}).


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=variable-lookup,caption=Lookup of a local variable.]
  (localContext variableNamed:'anObject') value.
\end{lstlisting}
\end{figure}

Some  languages actually perform all these steps at run-time, but most 
have a compiler help with efficiency by converting the names to indexes into
the local context and the value lookup into a simple indexed load from memory.

Most programming languages don't just optimize the implementation of the identifier
lookup operation, but also the interface.  Instead of having to specify how to
look up the identifier in the local context, the programmer can just write the
identifier {\bf anObject}, which the programming language will treat as equivalent to the
value that will be obtained by looking up the name in the local context.  


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=plain-identifier,caption=Identifier-oblivious variable lookup.]
  anObject.
\end{lstlisting}
\end{figure}

This  {\em identifier-oblivious} style shown in Listing~\ref{plain-identifier}, where lookup of the value bound to and
identifier is implied, is so familiar that we don't usually think about it, we just
refer to object using the identifier.
The alternative {\em identifier-aware} style shown in Listing~\ref{variable-lookup} would get cumbersome quickly.

Non-local entities such as sub-parts of constructed objects 
cannot be referred to symbolically by a single identifier.
Instead, they must be obtained using computation, a 
sequence of operations, which in Smalltalk is performed using message sends.



\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=non-local-reference,caption=Accessing objects via chained message sends.]
	myColor :=robot head leftEye color.
	robot head leftEye color: myColor.
\end{lstlisting}
\end{figure}

Listing~\ref{non-local-reference} shows both read and write access to the property
of a nested object structure using message-sends.  Note how symmetric operations
(read and write) require a non-symmetric implementation:  for the read, we have an assignment
from a series of chained messages, for the write we have a slightly different set of 
chained messages with the last message in the chain taking our desired value
as an argument.  In order to interact with an entity that should have a single name,
we need at least two names:  the getter and the setter.

This asymmetry is related to the fact that although we can hide an object reference 
behind a computational interface, we cannot
hide a computation behind a object reference interface, another asymmetry.
Thus any kind of external API has to be presented through a computational, messaging 
interface, even if the intention is not computation, but just access to a resource,
  and all information hiding also requires messaging.  This has led languages
like Self \cite{UngarS87} and Newspeak \cite{newspeak} to effectively abandon identifiers as direct symbolic names for objects. Instead there is only messaging and
all objects are obtained by sending messages to other objects.

On the World Wide Web with its REST architectural style the situation is exactly the inverse: 
the interface to resources is their identifier, the Uniform Resource Locator (URL, Listing~\ref{url-example}).
Wether computation happens in providing the resource is a hidden implementation detail
(ignoring the messaging protocols usually required to transmit the resource
to the client).  


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=url-example,caption=A Uniform Resource Locator.]
http://www.shipper.com/track/12345678
\end{lstlisting}
\end{figure}

So instead of having
a package-tracking application that takes a parameter (2 entities),
one can simply take the view that ``every package has its own 
Web-site'', which is then just one entity referenced by a single,
parameterless identifier.  This type of encapsulation behind
a single, parameterless identifier makes bookmarks and single-click,
browser-based navigation possible.


Instead of hiding references behind messaging,
messaging is hidden behind an identifier, and REST-ful Web-applications
perform computations by dereferencing a series of identifiers, that 
are provided incrementally and dynamically in responses.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=urn-example,caption=A Uniform Resource Name.]
urn:isbn:123123123
\end{lstlisting}
\end{figure}

Whereas URLs specify an access path including a network protocol, Uniform 
Resource Names (URNs) like the ISBN in Listing~\ref{urn-example} only specify a logical
name, leaving the resolution of that name completely open.  In a sense, URNs
correspond to interfaces.

Uniform Resource Identifiers (URIs) are a generalization of URLs, which specify a
resource by its protocol, network location, and access path and Uniform Resource Names (URNs),
which specify
a resource by a logical name and leave it to system processes to 
determine the exact location.  In practice, most URIs are located on
a continuum with URNs on one end and URLs on the other.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{User-defined identifiers}
\label{user-defined-identifiers}

Network resources identified by URIs are among the many entities that most
programming languages cannot refer to directly using identifiers available to the
language itself.
However, those entities still need to be addressed, so developers are required
to construct their own identifiers  and objects as well as methods for resolving them to the actual
entities.

\subsection{External resources}

Files, for example are referenced by their filename, or more precisely
a string that represents their access path in the filesystem (often from the root 
directory).  The operating system is responsible for mapping these
paths to entities allowing access to the contents of the file.  For example accessing
the current user's ``.bashrc'' file looks as follows:


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=posix-file-resolve,caption=Resolving a name to a file in the user's home directory.]
   char fullname[MAXPATHLEN];
   snprintf(fullname,MAXPATHLEN,"%s/.bashrc",
                            getenv("HOME"));
   int fd = open( filename );
   if ( fd >= 0 ) { 
      //... read contents of file using read()
      close(fd);
   }
\end{lstlisting}
\end{figure}

The string represents a user-defined identifier, which is just a plain character
string that has no meaning to the programming language and must be 
manually resolved by the developer in the {\em identifier-aware} style 
introduced in Section~\ref{identifiers}.  In fact, two different identifiers
are resolved in Listing~\ref{posix-file-resolve}:  first, the identifier {\bf HOME}
from the domain of environment variables is needed, which requires calling
the {\bf getenv()} function to resolve the identifier string to a value.  That result,
also a string, is then combined with the name of the file in question using generic
string processing functions and passed
to the {\bf open()} system call to return an actual file reference.  Boundary conditions
and error checking have been ignored to keep the sample manageable.

Convenience APIs can ameliorate the situation somewhat, for example shortening 
the multiple steps above into a single (slightly verbose) expression and making the
string processing safer.  However, they cannot
change the fundamental fact that the identifiers in question are basic strings,
manipulating them requires string processing and user-level resolution of the
string to an entity.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=cocoa-file-contents,caption=Cocoa convenience API for accessing file contents.]
   NSData dataWithContentsOfFile:
     ((NSProcessInfo processInfo
        environment 
        objectForKey:'HOME') 
       stringByAppendingPathComponent:'.bashrc')
\end{lstlisting}
\end{figure}

Which identifiers we can use in an oblivious style and which we need to
be aware of and resolve ourselves is pre-determined by the programming
language.
The same identifier that needs to be created using string processing from various
components in both the POSIX and the Cocoa can be written directly in a typical
Unix shell, including the variable part (Listing~\ref{sh-file-contents}).


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=sh-file-contents,caption=File contents in a shell.]
  cat $HOME/.basrhc
\end{lstlisting}
\end{figure}

The lack of string quotes is not just cosmetic: both the variable and the filename
are not just opaque strings, but entities that the shell is aware of and can identify
using the identifiers provided,for example being able to assist by autocomplete 
or wildcard expansion.


\subsection{Application-specific data representation}

\mpw{Also more efficient representations, such as {\em vertical}, storing arrays of values and indexes into those}

User-defined access is not restricted to external resources, but also
prevalent when code needs to interact generically with dynamic
or application-specific data.   Two examples of this usage pattern
 for user-defined access are user interfaces (UIs) and XML processing.

In UIs it is often required for
a specific UI item to modify some part of a model object, in our
example the color of the robots left eye.  In order for the UI element to be
able to manipulate the part, it needs to be parametrized at run-time with
an identifier that points to that part of a specific base object.   As the built-in
 identifiers typically are only available at compile-time, developers are
 once again forced to invent their own user-defined identifiers, which are again 
 typically string-based.  Since accessing objects via strings requires
 meta-programming, there is then often pressure to abandon data
 modeling with objects altogether and just use dictionaries everywhere.


DOM-based XML processors need to provide mechanisms to access parts of
an XML document, but except for the specific XML-data binding libraries that
require code-generation, the exact structure of the XML file is not known at 
compile-time and therefore built-in identifiers cannot be used.  Both DOM libraries
and more sophisticated query processors such as xpath or xquery therefore use
strings as their user-defined identifiers.




\subsection{The trouble with strings}
%\epigraph{The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.}{Alan Perlis}
\label{stringtrouble}

One aspect that virtually all user-defined identifier mechanisms have in common is that they
are based on string processing.  The use of strings makes user-defined identifiers relatively
close to language identifiers ({\bf \hbox{anObject}} vs {\bf \hbox{'anObject'}}), but brings with it a number of problems in terms of overhead, correctness, and safety.

As shown above, the first problem is that a string is not an identifier, and therefore
must be passed as an argument to some function or method to actually return
 an object, either doubling (function + identifier) or tripling (class/object + message + string ) the number of entities involved to retrieve the desired entity.  

The compiler does not have insight into strings that may be used as user-defined 
identifiers at some point in the future, and therefore cannot determine wether 
a string-based identifier is correct, or even syntactically well-formed.   The compiler
and runtime also cannot help with turning the identifier into a more efficient representation
like an index into a local store.  Instead, lookup must be performed using hash-tables
or other dictionary structures at runtime on individual path components, 
and complex paths must be first be decomposed into their components.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=url-as-obj,caption=URL initialized in an object-oriented fashion.]
u := NSURL alloc
           initWithScheme:'http'
           host:'www.example.org'
           path:'/' 
\end{lstlisting}
\end{figure}

All this run-time processing of strings is performed with general-purpose string
processing libraries that do not take the identifier semantics into account, with
many string operations capable of turning valid identifiers into invalid ones.
While it was fairly easy to paper over the differences between strings as 
data structures for human-readable text and strings as identifiers for programs,
the differences are becoming more obvious with internationalization, as the
problems making Perl UTF8 or Unicode aware demonstrate \cite{perl-unicode}

Mixing strings-as-user-data with strings-as-identifiers also has well known
security problems such as shell-escaping and SQL-injection, one of the
biggest sources of vulnerabilities on the Web.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=url-as-string,caption=URL initialized with a single string.]
u:=NSURL URLWithString:'http://www.example.org'
\end{lstlisting}
\end{figure}



On the other hand, using non-string types, while increasing safety somewhat,
obscures intent even further by breaking up the identifiers.
It is certainly debatable wether the more object-oriented
initialization of Listing~\ref{url-as-obj}  has any practical benefits over a
simple initialization from string as in Listing~\ref{url-as-string}, and in
the end the components are still strings and must be converted/combined
into the full URL at runtime.



In both cases, the part of the expressions that are actually semantically meaningful
to the programming language are just {\em syntactic noise}, they don't really carry
any meaning for the program but are necessary to make the syntax work.  The
embedded string, on the other hand, is the part that actually carries meaning for
the program, but is essentially opaque and meaningless to the programming
language.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=many-urls,caption=Many URLs with duplication]
u1 :=NSURL URLWithString:'http://www.example.org'.
u2 :=NSURL URLWithString:'http://www.metaobject.com'.
u3 :=NSURL URLWithString:'file:/tmp/testfile.txt'.

d1:=NSData dataWithContentsOfURL: u1.
d2:=NSData dataWithContentsOfURL: u2.
d3:=NSData dataWithContentsOfURL: u3.
\end{lstlisting}
\end{figure}

Listing~\ref{many-urls} illustrates the problem by showing the code for
creating 3 URLs and then fetching their contents.  Almost all of this code
is boilerplate that we should factor out, but it turns out that this factoring
can only go so far.  Listing~\ref{many-urls-factored1} shows one possible
factoring, which pushes the responsibility for resolving URLs into the
URL representation class, though that could also be a separate Resource 
Manager. 

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=many-urls-factored1,caption=Partial factoring]
d1:=NSURL contentsOfURLString:'http://www.example.org'.
d2:=NSURL contentsOfURLString:'http://www.metaobject.com'.
d2:=NSURL contentsOfURLString:'file:/tmp/testfile.txt'.

\end{lstlisting}
\end{figure}

An ideal factoring would remove all the repeated boilerplate code, but in this case
that would leave just the strings, leading to the incorrect factoring in Listing~\ref{urls-factored-ideally}.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=urls-factored-ideally,caption=Ideal but incorrect factoring]
d1 :='http://www.example.org'.
d2 :='http://www.metaobject.com'.
d3 :=' file://tmp/testfile.txt'.
\end{lstlisting}
\end{figure}

The reason this factoring is ideal is that it has eliminated all the repeated boilerplate code, the
reason that it is incorrect is that the naked strings carry no semantics other than just being
character sequences, there is no entity to evaluate the URIs within the strings.

A solution that would allow this factoring to take place would be let the programming
language implicitly evaluate those character strings, just like it does with other
identifiers.  In order to make this happen, the notion of identifier has to be expanded
slightly and we will need some extra infrastructure to make it all possible.


%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Polymorphic Identifiers}
\label{polymorphic-identifiers}
%\epigraph{A change in perspective is worth 80 IQ points}{Alan Kay}

With Polymorphic Identifiers, the ideal but incorrect factoring of Listing~\ref{urls-factored-ideally}
can be converted into a correct factoring of Listing~\ref{several-pis} by leaving out the quotation marks.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=several-pis,caption=Corrected ideal factoring]
d1 := http://www.example.org.
d2 := http://www.metaobject.com.
d3 := file://tmp/testfile.txt
\end{lstlisting}
\end{figure}

Polymorphic Identifiers replace the static identifiers found in programming languages with
a dynamic, user-extensible system for resource access, wether those resources exist
on a stack frame or on the world wide web.

Syntactically, \emph{polymorphic identifiers} are Universal Resouce Identifiers (URIs) \cite{rfc3986}.
The choice of URI syntax was pragmatic:
they already exist, most people are familiar with them, they are widely used
and come close enough to the universality claimed by their name as to make no difference.

In fact, one way of regarding polymorphic identifiers is that they add direct language support
for URIs to a language.  Although that view may be initially helpful, it is misleading in
the end, because URIs are generally only used to specify resources outside of a process,
whereas polymorphic identifiers unify and generalize both process-internal and -external identifiers.

The unification means that both external and internal resources can be addressed in either
identifier-oblivious or identifier-aware styles, the arbitrary distinction demonstrated in
the previous sections is removed.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=first-polymorphic-examples,caption=\emph{Polymorphic identifiers} in simple expressions.]
  http://www.acm.org/
  joesBashrc := file:/Users/joe/.bashrc
  file:/Users/mike/.bashrc := joesBashrc
  pdf := MPWPDFFile pdfFileWithData: file:document.pdf.
\end{lstlisting}
\end{figure}


Since polymorphic identifiers completely replace standard identifiers, they can be used
in arbitrary expressions the same way one would expect of any other identifier.  
Listing~\ref{first-polymorphic-examples} shows polymorphic identifiers used 
standalone as a network access, in assignment statements that read or write disk files,
and as an argument in a message expression.


\begin{figure}[htbp]
\caption{Components of the PI system}
\label{scheme-eval}
\begin{center}
\includegraphics[scale=0.45,page=1]{scheme-evaluation.pdf}
\end{center}
\end{figure}

Figure~\ref{scheme-eval} shows the components of the PI system:  the polymorphic
identifiers themselves, the scheme-handlers which evaluate PIs and the references
which mediate actual access to the resources.

In this case, the scheme part of the
polymorphic identifier selects the {\tt http} scheme-handler, which evaluates the {\em scheme-specific}
part of the URI ({\tt //www.ietf.org/rfcs/1384.txt} and returns a reference, in this case a 
web-reference.   The web-reference then uses an http client library to interact with the
actual web-server using GET/PUT requests.

The three steps can happen at compile- or run-time and can be partially completed.
A reference to a local stack variable, for example, will typically have none of the
three components visible at run time, with all that remains being optimized 
machine code to directly access the resource (the stack variable).
A file or web-reference, on the other hand, will typically have the PI itself
compiled, with evaluation deferred until runtime.  Finally, there are facilities
for turning strings into PIs at runtime.


\section{Schemes and scheme handlers}

Schemes are the main point of variability in the PI system
and broadly fall into two categories:   {\em primitive schemes}(\ref{primitiveSchemes})
directly encapsulate access to some sort of resource, while {\em composite schemes} 
take other schemes as arguments and modify their behavior.

Users can define their own schemes and add that 
to the system, either by writing
a new primitive scheme handler, by applying composite schemes or by writing new types
of composite scheme handler.  Built-in schemes are not privileged over user-defined
schemes except where necessary to avoid infinite recursion.

Scheme handlers are normal objects that respond to a well-defined protocol.  They
become part of the language by adding them to a special scheme, the {\em scheme scheme}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=scheme-scheme-http,caption=Adding the http and file schemes.]
  scheme:http := URLSchemeResolver scheme.
  scheme:file := FileSchemeResolver scheme.
\end{lstlisting}
\end{figure}

Listing~\ref{scheme-scheme-http} shows the binding of the {\bf http} and {\bf scheme}
handlers to actual scheme handlers that will subsequently process any polymorphic
identifiers with the {\tt http} or {\tt file} schemes, respectively. 

It is both possible and common to bind other handlers to those scheme
names, for example an {\bf http} handler that implements a multi-level caching scheme
or a {\bf file} scheme served from memory for testing purposes.  Any scheme-handler
can be used for any scheme-name, as long as it implements the handler protocol
compatibly.

Note that perfect interoperability is not guaranteed or required, so there is no notion
of transparent remote access, for example.  Different scheme handlers will have different supported
data types, different access modalities and different levels of quality of service.
Polymorphic identifiers only remove syntactic incompatibility for accessing different types
of resources when those resources are semantically compatible within the parameters
of the requesting application.


The {\em scheme scheme} can also be queried,
so the expression {\bf scheme:http} returns the currently installed http handler, and 
{\bf scheme:scheme} returns the scheme scheme itself, which will list the currently
installed schemes.  Listing~\ref{scheme-scheme} shows the schemes installed by
default in the scripting environment {\tt stsh}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=scheme-scheme,caption=List of schemes via scheme:scheme.]
> scheme:scheme 
scheme-resolver with the following schemes: (
    file,
    ftp,
    default,
    var,
    bundle,
    defaults,
    sel,
    mainbundle,
    scheme,
    http,
    env,
    ref,
    class,
    https
)
\end{lstlisting}
\end{figure}

\subsection{Primitive Schemes}
\label{primitiveSchemes}

Primitive schemes are the endpoints for resource access, they directly
mediate access to the resource in question.  Primitive schemes
subsume both what is normally considered variable access and 
what is usually considered I/O, network and filesystem access.



\subsubsection{External resources}
\label{externalResources}

The list of default scheme-handlers in listing~\ref{scheme-scheme} contains a few familiar URI schemes:
{\tt http} and {\tt https}, {\tt ftp}, {\tt file}.   These behave in the expected way:   referencing them in an expression will
retrieve the bytes from the web-server, FTP-server or file, and placing them on the left hand side of
an assignment statement will perform an HTTP or FTP PUT request or write to a file system.



\subsubsection{In-memory access}
\label{inmemory}

So far, we have simply added file and Web-access via URLs to a 
Smalltalk-like programming language.  However it turns out that we can actually generalize
this approach to all identifier usage, including normal variable access, using
two additional schemes:  the {\bf var} scheme and the {\bf default} scheme.

The {\bf var} scheme refers to in-memory variables, so the expression
 {\bf var:anObject} references the
local variable {\bf anObject}.   Compound paths can be given and are resolved in
cooperation with the object.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=in-memory-path,caption=In-memory access path.]
  myColor := var:robot/head/leftEye/color.
  var:robot/head/leftEye/color := myColor.
\end{lstlisting}
\end{figure}

Listing~\ref{in-memory-path} recasts the structured access from 
Listing~\ref{non-local-reference} using \emph{polymorphic identifiers}.  Unlike the variant
with chained message-send, the operations are symmetric in the case of \emph{polymorphic identifiers}.

The {\tt thread} scheme encapsulates thread-local variables using the {\tt pthread} thread
local storage API and the {\tt dyld} scheme encapsulates dynamic access to
named variables via the {\tt dlsym} family of functions.

A scheme that straddles the fence between an in-memory and an external 
scheme is the {\tt env} scheme, which encapsulates access to the Unix
environment via the {\tt getnv()} and {\tt putenv()} functions.  Although 
values are not stored in persistence storage, they can outlast the
current process and also need to be serialized into character sequences.

A further scheme handler that is not pre-loaded but available for defining
custom schemes is the {\tt SiteMap}.  A {\tt SiteMap} stores arbitrary objects
in memory in a tree structure that acts a bit like a memory filesystem.

\subsection{Composite Schemes}

Composite schemes combine create a new scheme by combining one or 
more existing schemes and applying processing to the identifiers, retrieved
resources or both.


One example is the relative scheme resolver, which takes a base-binding
and evaluates its references relative to that base.  Listing~\ref{rfc-scheme} shows
how to use a relative scheme resolver to build a scheme that can directly
reference Internet Engineering Task Force Request For Comments (IETF RFCs).
The end effect is that we can hide the actual location and access method for
the IETF RFCs behind a scheme so we can access those RFCs directly and
creating a URI scheme that is close to a URN.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=rfc-scheme,caption=Retrieving RFC 2396 (URI Syntax) via custom rfc: scheme.]
  base := ref:http://datatracker.ietf.org/doc/.
  scheme:rfc := RelScheme schemeWithBase:base.
  uriSyntax := rfc:rfc2396.
\end{lstlisting}
\end{figure}

Another is a cache scheme, which has two schemes as its arguments,
the base and the cache.  When accessed, the cache scheme first
checks the scheme that was designated as its cache.  If the resource
is found there, it is returned.   If the resource is not found in the cache
it is retrieved from the base scheme and placed in the cache in addition
to being returned.

Using the http- and file-schemes from section~\ref{externalResources}, the
{\tt SiteMap} from section~\ref{inmemory} and the cache and
relative schemes defined here, we can create the 
caching behavior of a typical http stack just by composing
pre-existing schemes, as shown in figure~\ref{http-cached}.


\begin{figure}[htbp]
\caption{A caching http stack made from composed schemes}
\label{http-cached}
\begin{center}
\includegraphics[scale=0.55,page=1]{cached-http.pdf}
\end{center}
\end{figure}

The code to implement this composed, caching http scheme is not all 
that different from the diagram.  It is shown in listing~\ref{http-composed-listing}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=http-composed-listing,caption=Code for caching http stack.]
rawhttp := scheme:http.
tempref := ref:file/tmp/ asScheme.
diskCache := CacheScheme cacheWithScheme: tempref.
memoryCache := CacheScheme memoryCache.
scheme:http := 

 rawhttp -> diskCache -> memoryCache.
\end{lstlisting}
\end{figure}

The {\tt ->} connector composes components by their default input
and output ports.

The cache-scheme is really just a special case of a binary composite scheme,
which can be also be used to implement copy-on-write behavior similar to
VPRI's world concept\cite{vpriworlds}.

A {\em filter-scheme} applies custom processing to the identifiers going to
its source scheme and the data flowing in and out.  A special case of the 
filter scheme is the mime-mapper.  It turns serialized data obtained from
external resource schemes such as {\tt file} or {\tt http} into domain objects
using blocks keyed by mime-type.  

\begin{figure}[htbp]
\caption{Adding conversion to the caching http-stack}
\label{http-cached-converted}
\begin{center}
\includegraphics[scale=0.55,page=1]{cached-and-mapped-http.pdf}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=http-cached-converted-listing,caption=Caching and converting.]
rawhttp := scheme:http.
tempref := ref:file/tmp/ asScheme.
diskCache := CacheScheme cacheWithScheme: tempref.
memoryCache := CacheScheme memoryCache.
mapper := MIMEMapper defaultMapper.
scheme:http := 

 rawhttp -> diskCache -> memoryCache -> mapper.
\end{lstlisting}
\end{figure}


With the mime-type mapper in place, it might make more sense to
cache the deserialized representation in memory rather than
the raw bytes.  This change in caching strategy only requires
the minimal change in the configuration of the composed http-scheme
shown in figure~\ref{http-converted-cached}.

\begin{figure}[htbp]
\caption{Caching the converted object}
\label{http-converted-cached}
\begin{center}
\includegraphics[scale=0.55,page=1]{mapped-and-cached-http.pdf}
\end{center}
\end{figure}

Listing~\ref{http-converted-cached-listing} again closely follows the
diagram in figure~\ref{http-converted-cached}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=http-converted-cached-listing,caption=Converting and caching.]
rawhttp := scheme:http.
tempref := ref:file/tmp/ asScheme.
diskCache := CacheScheme cacheWithScheme: tempref.
memoryCache := CacheScheme memoryCache.
mapper := MIMEMapper defaultMapper.
scheme:http := 

 rawhttp -> diskCache -> mapper -> memoryCache.
\end{lstlisting}
\end{figure}


\subsection{Default scheme}


The {\bf default} scheme is not an actual scheme per-se, but rather a special slot
that is used in resolving identifiers encountered without a scheme-specifier.
In that case, the scheme registered under the {\bf default} scheme is used
instead, which when combined with the {\bf var} scheme that is the default
for the {\bf default} scheme gives the semantics for a naked identifier (e.g. {\bf robot}).

However, the default scheme can be set to some other scheme if that is more
convenient for the task at hand, as shown in Listing~\ref{file-as-default-scheme},
where a file copy is performed after the default scheme is set to file.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=file-as-default-scheme,caption=File copy with file: as default scheme.]
  scheme:default := scheme:file.
  myBashRc := .basrhc.
\end{lstlisting}
\end{figure}

One syntactic limitation of the default scheme mechanism is that it does not allow
compound paths, so for compound paths a full URI with scheme must be used.




\section{First class references}

The bindings that are returned by scheme-resolvers are usually ephemeral, used just 
to get to the value pointed to by the identifier, either reading or writing it.  This
makes it possible to program with arbitrary and user-defined identifiers in
an identifier-oblivious style.  It also means that for sufficiently simple scheme-resolvers,
the binding can actually be elided if the compiler can determine that it is not needed.

However, as we saw earlier, it is sometimes
desirable to use the identifier-aware style.  In order to do this, the language
must provide access to the bindings used in resolving the identifier.

The {\bf ref} scheme prevents evaluation of the binding and thus allows access
to the binding itself.  Listing~\ref{ref-binding} illustrates the syntax and semantics:
first a variable {\bf a} is defined and bound to a value 42, then we obtain a reference {\bf b} to
the identifier for the first variable {\bf a}.  We can now manipulate variable {\bf a} 
in a generic way through the reference we have obtained in variable {\bf b} without
having a hard-coded reference. 


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=ref-binding,caption=Accessing a variable via its binding.]
  a := 42.
  b := ref:var:a.
  b value  -> 42.
  b bindValue:2.
  a -> 2.
\end{lstlisting}
\end{figure}

This generic access to variables (or more generally: resources) can be used just as well
with complex identifiers that have multi-element paths.  So for example a UI element
could get the reference {\bf ref:var:robot/head/leftEye/color} and would then be
able to manipulate the eye-color of the left eye of that particular robot safely using
the message {\bf value} and {\bf setValue:}
without having to know about or traverse the structure in question.

Common operations on bindings are retrieving, binding and unbinding a value and testing 
wether a binding has a value, as shown in Listing~\ref{isBound} for the {\bf env} scheme
that provides access to Unix environment variables.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=isBound,caption=Is environment variable set?]
> ref:env:bozo isBound  -> 0
> env:bozo := 'hi'
> ref:env:bozo isBound  -> 1
\end{lstlisting}
\end{figure}

Bindings are scheme-specific and can include additional API specific to that type of scheme.
For example, file bindings are analogues of the Java {\bf File} object and can deliver
meta-data about and perform operations on the file as shown in Listing~\ref{ref-file-dir}.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=ref-file-dir,caption=File and directory manipulation.]
> newDir := ref:file:testDir 
> newDir isDirectory  -> 1
\end{lstlisting}
\end{figure}

Bindings for remote resources include methods for initiating a transfer, cache-control,
error-checking and progress monitoring.   Bindings can be passed to user interface
elements for manipulation of the object referenced.




\section{Evaluated identifiers}

With richer identifiers, it makes sense to allow abstractions to be built with these identifiers.
One example is parametrization, with an identifier having parameters that are evaluated
at runtime.  Curly brackets \{\} denote a section of the path that should be evaluated and
the return value used as part of the access path.

Listing~\ref{bashrc-pi} shows an example where the current user's home directory
is retrieved from the Unix environment using the {\bf env} scheme and the resulting
path is then used to obtain the current user's  {\bf .bashrc}.
It is equivalent to Listings~\ref{posix-file-resolve}, \ref{cocoa-file-contents}, and 
\ref{sh-file-contents}.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=bashrc-pi,caption=Parametrized identifier.]
  file:{env:HOME}/.bashrc
\end{lstlisting}
\end{figure}


Different abstraction mechanisms can be combined, for example yielding
a scheme that represents file in the current user's home directory, shown
in Listing~\ref{home-scheme}.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=home-scheme,caption=Accessing .bashrc via custom home: scheme.]
  base := ref:file:{env:HOME}.
  scheme:home := RelScheme schemeWithBase:base.
  home:.bashrc.
\end{lstlisting}
\end{figure}

A sequential composition scheme simply searches a list of other schemes
for a particular identifier.  It searches its argument schemes sequentially
for the identifier in question and returns the first match.  Lookup rules for
identifiers that are usually hard-coded into languages can be expressed
as a sequential composition scheme, for example:   \{ scheme:local ,
scheme:ivar , scheme:classvar , scheme:poolvar , scheme:global \} for Smalltalk 
(ignoring the capitalization rules for now).

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%



\section{Implementation}
\label{implementation}

\emph{Polymorphic identifiers} have been implemented as part of Objective-Smalltalk \cite{objst},
a Smalltalk dialect built on top of the Objective-C\cite{objc-evol}\cite{objc-apple} runtime, 
in a way that is similar to FScript\cite{fscript} and MacRuby \cite{macruby}.

Objective-C is an ahead-of-time-compiled, hybrid, and dynamic object oriented programming language
that is an extension of C.  The object-oriented extensions to C are closely modeled on
Smalltalk, with dynamic single-dispatch at runtime, a keyword syntax and classes as
largely first-class objects.

Objective-Smalltalk objects and classes are Objective-C objects, they are created using
the same functions and data structures and are indistinguishable at runtime.
The same goes for Objective-Smalltalk methods, which are also indistinguishable from
Objective-C methods, making Objective-Smalltalk in a sense a meta-circular language
that is written in itself, or more precisely written in variants of itself \cite{kleinvm}\cite{squeak}.



\subsection{Example}

Listings~\ref{get-env}-\ref{hasValue-env} show the implementation of a simple scheme,
the env-scheme that provides access to Unix environment variables.  While this scheme
is actually string-based, that fact is hidden and the strings are not exposed to the user.
Listing~\ref{get-env}
shows the {\bf bindingForName:inContext:} method that is the main access point for
converting from an identifier to a binding.  In this case, a generic binding object is returned
that simply stores the name of the identifier and lets the scheme that created it resolve
access via the {\bf valueForBinding:} and {\bf setValue:forBinding:} methods.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=get-env,caption=Basic lookup in env: scheme.]
-(const char*)cstringValueOfBinding:aBinding
{
  return getenv([[aBinding name] UTF8String]);
}

-bindingForName:aName inContext:aContext
{
  return
    [GenericBinding bindingWithName:aName scheme:self];
}

-valueForBinding:aBinding
{
  const char *val=[self cstringValueOfBinding:aBinding];
  if ( val ) {
    return [NSString stringWithUTF8String:val];
  } else {
    return nil;
  }
}
\end{lstlisting}
\end{figure}

In this case, the name of the identifier is simply passed to the POSIX {\bf getenv()} function.
Setting the value is handled in an analog fashion using the {\bf setenv()} function.


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=setvalue-env,caption=Set value in env: scheme.]
-(void)setValue:val forBinding:binding
{
  val=[newValue stringValue];
  if ( val  ) {
    setenv([[binding name] UTF8String],
      [value UTF8String],1);
  } else {
    unsetenv([[binding name] UTF8String]);
  }
}
\end{lstlisting}
\end{figure}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=hasValue-env,caption=Checking for presence of value in env: scheme.]
-(BOOL)isBoundBinding:aBinding
{
  return 
    [self cstringValueOfBinding:aBinding] != NULL;
}
\end{lstlisting}
\end{figure}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=url-args,caption=URL arguments via reference and higher order message.]
  host := 'citeseerx.ist.psu.edu'.
  viewCiteSeer:=ref:http://{host}/viewdoc/summary.
  viewCiteSeer getWithArgs doi:'10.1.1.41.7628'.
\end{lstlisting}
\end{figure}

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Related Work}
\label{related-work}

There has been a lot of work on extensible languages, but very little of that work 
has focused on identifiers.  

\subsection{Path-based access in languages}

Programming languages such as C, C++ or Pascal have facilities for composite
identifiers, for example using the dot or {\bf -> } operators in C, but these facilities allow
direct access to the internal data, without any ability of the structure in question to 
mediate.  The same thing goes for passing a pointer to a substructure:  while it
does give a single entity that can be used to access a sub-part of a structure, it
does so without any access controls.

Properties in C\# and Objective-C 2.0 allow a variable-access interface to be backed by 
message sending, thus allowing path-based access under dynamic control of the object
in question, but without having first-class references or the ability to access other
types of resources using a unified mechanism.

ThingLab\cite{thinglab}  adds path-based access to the base Smalltalk language in order to support
constraints referencing parts of objects, say the vertex of a triangle, and these
references do exist as first class objects that can be passed to other objects.
   It does not
expand this path-based access to other domains or make it user-extensible.

AppleScript\cite{applescript-hopl3} exposes a program's object model via
phrases that correspond to access path.  Listing~\ref{AppleScript} shows 
how to access the title of the currently playing iTunes track and set this
as the current iChat status message.

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label= AppleScript,caption=Using AppleScript to set chat status from track name.]
  tell application "iTunes"
    set trackname to name of current track
  end tell
  tell application "iChat"
    set status message to trackname
  end tell
\end{lstlisting}
\end{figure}

With \emph{polymorphic identifiers}, the same operation can be expressed
much more concisely as a simple assignment between two URIs,
as shown in Listing~\ref{NonAppleScript}


\begin{figure}[htbp]
\begin{lstlisting}[style=L,label=NonAppleScript,caption=Access to applications via \emph{polymorphic identifiers}.]
  app:iChat/statusMessage := app:iTunes/currentTrack/name.
\end{lstlisting}
\end{figure}


\subsection{Unified path-based access mechanisms}


User level filesystems like FUSE\cite{fuse} or the BSD Pass-to-User-Space\cite{puffs} 
system allow
user-level code to add new filesystems to the Unix kernel, without requiring
kernel modifications or impacting operating system kernel stability.

This approach allows many sorts of local and remote data-types to be 
treated as files in a filesystem and made available to the wide variety
of Unix tools that can navigate and process such files.  

However, this support requires global installation of handlers in the operating
system, which also must mediate access, making integration of in-memory 
variables difficult at best.  The identifiers used to access these resources
are also still strings that are not integrated with the identifier mechanism of
the host language, with all the problems discussed in Section~\ref{stringtrouble}.

Using FUSE/puffs filesystems as scheme resolvers without kernel intervention seems
like a useful addition, as is making scheme-resolvers available to the Unix kernel
via FUSE/puffs.

The Plan9\cite{plan9names}\cite{plan9network} operating system from Bell Labs goes further than FUSE in integrating
all data, local and network resources into a single hierarchical namespace.  Similar
caveats as for FUSE apply.

Phantom XML\cite{phantomxml} unifies access to data by treating all data as
XML trees, allowing queries against this XML representation of the data without
actually converting it to XML first.  




\subsection{URIs in E}

The E language\cite{MillerRobustComposition}  supports URI-Expressions as a
direct language feature.  Example include access to files
using file URI  {\bf <file:c:/jabbertest>} or Web-resources using HTTP {\bf <http://www.erights.org>}.  However,
E only supports using these URI expressions in the reference-aware style and does not integrate 
ordinary identifiers into the URI mechanism, provide abstraction facilities 
for URIs or an extension mechanism. 


\subsection{References in Icon}

In the Icon programming language \cite{IconRef} , identifiers (references) can be first class values,
and there are complex rules for when a reference remains a reference and when
it's value is used.  However, the rules are implicit and there is no way for the 
developer to choose when to be identifier-aware or identifier-oblivious.  Furthermore,
there is no way for the user to extend the language with new types of references 
or behaviors.



\subsection{Domain specific languages}

\emph{Polymorphic identifiers} are similar to Embedded Domain Specific Languages\cite{edsl}
in that they allow domain-specific language elements to be added to a language, rather
than having to create a completely new language with an external DSL or attempt to 
achieve the desired effect with an internal DSL\cite{fowlerdsl}.  

Like polymorphic embedding of DSLs \cite{polydsl}, \emph{polymorphic identifiers} allow
a single syntax to be used with multiple, pluggable semantic interpretations permitting
composition of functionality\cite{embeddeddsl}.  However, \emph{polymorphic identifiers}
are applicable to general purpose programming languages, not jus DSLs, while
at the same time restricting their focus to just the identifiers used.

\subsection{Proxies, mirrors, and mirages}

Smalltalk reflective facilities \cite{reflective-st} have long been used to build
facilities such as distributed object systems, futures, lazy evaluation and
transparent storage mechanisms.  One problem with the Smalltalk facilities
has been that they are defined in an ad-hoc fashion from error handling routines
and not sufficiently stratified, with meta-level functions
interfering with base-level functions and vice-versa.  Another problem is that
most reflective techniques only apply to messages, not to identifiers, making 
those techniques unavailable.

Mirrors \cite{mirrors} and Mirages \cite{mirages} improve the stratification and
reflection/intercession capabilities, but are not capable of dealing with pure
identifiers or of bringing user-defined resource handlers into the language.

The proposed ECMAScript Proxy mechanism \cite{VanCutsemMiller} addresses
the stratification issues and also integrates some identifier access into the 
metaprogramming framework, but doesn't allow user-extensible identifiers.

We believe that mechanisms such as remote objects, futures, proxies and the like
are actually properly modeled not at the object level, but at the identifier/reference
level, so that a significant part of what is currently considered metaprogramming
can be considered programming at the identifier level.

\subsection{Internet programming languages and systems}

The success of the REST architectural style\cite{fielding-rest} on the Web has sparked
systems and languages that try to more directly model and take advantage of that
style.

The Wheat language \cite{wheat} embedded an entire programming language
and system into a Web-server, accessing all resources and methods via
HTTP URLs.  \emph{Polymorphic identifiers} allow resources, but these resources
are not required to use a specific communications mechanism.


Resource Oriented Computing \cite{roc} goes even further by
requiring all computation to be expressed through URIs, adding Active URIs
for computation as shown in Listing~\ref{activeuri}.   


%\begin{figure}[htbp]
%\begin{center}
%\begin{small}
%\begin{verbatim}
%active:{base}+{name}@{uri}...
%\end{verbatim}
%\end{small}
%\caption{Active URI}
%\label{activeuri}
%\end{center}
%\end{figure}

\begin{figure}[htbp]
\begin{lstlisting}[style=L,label= activeuri,caption=Active URI.]
  active:{base}+{name}@{uri}...
\end{lstlisting}
\end{figure}

The {\bf base} is a function name, the {\bf name} an argument name and the
{\bf uri} an argument URI.
 While \emph{polymorphic identifiers} allow processing to be
hidden behind a resource URI, they also allow messaging to be expressed
as messaging when that is the intent.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

\section{Summary and Outlook}
\label{summary-and-outlook}

We examined both built-in and user-defined identifiers in programming languages 
and separated their usage patterns into an {\em identifier-oblivious} style where
the identifier is used by itself to denote its bound value and the 
an {\bf identifier-aware} style where the identifier itself is used as a first class value
and its value can only be accessed indirectly.

While each style is appropriate in different usage-scenarios, current languages 
tie the usage style to wether the identifier is built-in or user-defined.  \emph{Polymorphic
identifiers} remove the distinction between user-defined and built-in identifiers by having
a single type of user-extensible identifier that can be used in both identifier-oblivious
and identifier-aware styles.

With a user-extensible identifier architecture, it becomes possible to add abstraction
and information-hiding capabilities to identifiers and expand the use of REST-style
programming beyond network and Web-environments.

%-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=%

%\appendix
%\section{Appendix A}

%This is the text of the appendix, if you need one.

%\acks

%Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\vfill
\break

\bibliographystyle{abbrv}

% The bibliography should be embedded for final submission.
\bibliography{polymorphic-identifiers}

\balancecolumns
\end{document}
