%-----------------------------------------------------------------------------
%
%    Domain Specific Identifiers
%
%-----------------------------------------------------------------------------


\documentclass[preprint,authoryear,10pt]{sigplanconf}


\usepackage{amsmath}
\usepackage{epigraph}
\usepackage[colorlinks=true,
        linkcolor=black,
        citecolor=black,
        filecolor=black,
        pagecolor=black,
        urlcolor=black,
        bookmarks=true,
        bookmarksopen=true,
        bookmarksopenlevel=3,
        plainpages=false,
        pdfpagelabels=true]{hyperref}

\begin{document}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2011} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Polymorphic Identifiers}
%\subtitle{Subtitle Text, if any}

\authorinfo{Marcel Weiher}
           {metaobject ltd.}
           {marcel@metaobject.com}
\authorinfo{Robert Hirschfled}
           {Hasso Plattner Institut}
           {hirschfeld@acm.org}

\maketitle

\begin{abstract}
We introduce polymorphic identifiers, a generalization of the monomorphic identifiers found in most
programming languages today as first class objects, as well as mechanisms for
resolving those identifiers and binding them into a general purpose programming language.
These identifiers allow stratified designs clearly separating meta- and base-level constructs
as well as light-weight domain-specificity with high levels of expressiveness, 
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms 
\keywords
\setlength{\epigraphrule}{0pt}


\section{Introduction}
\epigraph{There are only two hard things in Computer Science:  cache invalidation and naming things} {Phil Karlton}

This is not a paper about cache invalidation.  Mostly.   Rather, we report on an experimental
technique for expanding our ability to directly name many different things in 
programming languages using a common and extensible identifier and identifier resolution
mechanism.
These polymorphic identifiers are not just user-extensible,
but can also be manipulated in the programming language, making them first class 
entities.

Our starting point is a programming model such as that of Smalltalk, where we have objects
that communicate via messages\cite{Goldberg1983}.   Identifiers are used to identify 
objects, but are early bound by the compiler and resolved to slots in local contexts, and 
global, instance-, class- or pool-variables.  Late-binding of names, encapsulation and
polymorphic behavior can only be achieved with message sends.

We then give various examples both of additional things that one might want to reference 
 apart from objects resident in a single address space  and
desirable operations on identifiers beyond resolving them to objects at compile time.

We believe that the accidental complexity \cite{Brooks87nosilver} introduced by the
plethora of ad-hoc mechanisms for addressing these desiderata can be reduced 
by unifying them using the polymorphic identifiers introduced in this paper.


\section{Identifiers}
\label{identifiers}
\epigraph{When programming a component, the right computation model for the component is the least expressive model that results in a natural program.}{Rule of Least Expressiveness.}

Identifiers are symbols that serve as human-readable names for entities/objects
in a program.  They are converted to actual references, usually with a mixture of
compile-time and run-time lookups.  For example, to obtain the value of the local
variable named {\bf anObject}, one would have to search the local context for
a slot named {\bf 'anObject'} and then return the value stored at that slot.


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
(localContext variableNamed:'ÕanObjectÕ') value.
\end{verbatim}
\caption{Lookup of a local variable}
\label{variable-lookup}
\end{center}
\end{figure}


Some  languages actually perform all these steps at runtime, but most 
have a compiler help with efficiency by converting the names to indexes into
the local context and the value lookup into a simple load from memory.

Most programming languages don't just optimize the implementation of the identifier
lookup operation, but also the interface.  Instead of having to specify how to
look up the identifier in the local context, the programmer can just write the
identifier {\bf anObject}, which the programming language will treat as equivalent to the
value that will be obtained by looking up the name in the local context.  


\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	anObject.
\end{verbatim}
\caption{Identifer-oblivious variable lookup}
\label{plain-identifier}
\end{center}
\end{figure}

This  {\em identifier-oblivious} style shown in Figure~\ref{plain-identifier}, where lookup of the value bound to and
identifier is implied, is so familiar that we don't usually think about it, we just
refer to object using the identifier.
  The 
alternative {\em identifier-aware} style shown in Figure~\ref{variable-lookup} would get cumbersome quickly.

Non-local entities such as sub-parts of constructed objects 
cannot be referred to symbolically by a single identifier.
Instead, they must be obtained using computation, a 
sequence of operations, which in Smalltalk is performed using message sends.
For example, assuming we have a model of a robot, we might obtain the
color of the robot's left eye as follows:

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	robot head leftEye color.
\end{verbatim}
\caption{Obtaining a reference via chained message sends}
\label{non-local-reference}
\end{center}
\end{figure}


Although we can hide an object reference behind a computational interface, we cannot
hide a computation behind a object reference interface.
Thus any kind of external API has to be presented through a computational, messaging 
interface, even if the intention is not computation, but just access to a resource,
  and all information hiding also requires messaging.  This has led languages
like Self \cite{UngarS87} and Newspeak \cite{BrachaNewspeak} to effectively abandon identifiers as symbolic names for objects, 
all objects are instead obtained by sending messages to other objects.

\begin{itemize}
\item [mpw] not sure I have clearly explained this (the issue with computational 
\end{itemize}

In the World Wide Web on the other hand, access  to  resources is
through Universal Resource Identifiers.  A client just provides a URI,
and the browser or other access software retrieves the resource 
identified.   The resource may be a static or computed, the client has 
no way of knowing this.  So instead of hiding a simple declarative
computational model behind a more complex computational one,
the WWW hides a complex computational model behind the simple
declarative one.

On the Web, everything is just a document that has a name, even 
if it may be backed/generated dynamically by an application.  So instead of having
a package-tracking application that takes a parameter ( 2 entities),
one can simply take the view that ``every package has its own 
web-site'', which is then just one entity referenced by a single,
parameterless identifier.


URIs are a generalization of Uniform Resource Locators, which specify a
resource by its network location and access path and Uniform Resource Names,
which specify
a resource by a logical name and leave it to system processes to 
determine the exact location.  In practice, most URIs are located on
a continuum with URNs on one end and URLs on the other.

\section{User-level identifiers}

In addition to the entities that can be referred to directly by the programming language's 
built-in identifiers, there are many other entities that typically cannot.  However,
these entities still need to be referenced somehow, so developers are required
to construct their own identifiers and methods for resolving them to the actual
entities.

Files, for example are usually referenced by their filename, or more precisely
a string that represents their access path in the filesystem from the root 
directory.   The operating system is responsible for mapping these full
paths to entities allowing access to the contents of the file.  For example accesing
the current user's ``.bashrc'' file looks as follow:

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
   char fullname[MAXPATHLEN];
   snprintf(fullname,MAXPATHLEN,"%s/.bashrc",
                            getenv("HOME"));
   int fd = open( filename );
   if ( fd >= 0 ) { 
      //... read contents of file using read()
      close(fd);
   }
\end{verbatim}
\caption{Resolving a name in the user's home directory to a file}
\label{posix-file-resolve}
\end{center}
\end{figure}

The string represents a user-level identifier, which is just a plain character
string that has no meaning to the programming language and must be 
manually resolved by the developer in the {\em identifier-aware} style 
introduced in Section~\ref{identifiers}.  In fact, two different identifiers
are resolved in Figure~\ref{posix-file-resolve}:  first, the identifier {\bf HOME}
from the domain of environment variables is needed, which requires calling
the {\bf getenv()} function to resolve the identifier string to a value.  That result,
also a string, is then combined with the name of the file in question and passed
to the {\bf open()} system call to return an actual file reference.  Boundary conditions
and error checking have largely been elided.

Convenience APIs can ameliorate the situation somewhat, for example shortening 
the multiple steps above into a single (slightly verbose) expression and making the
string processing safer.  However, they cannot
change the fundamental fact that the identifiers in question are basic strings,
manipulating them requires string processing and user-level resolution of the
string to an entity.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
   NSData dataWithContentsOfFile:
     ((NSProcessInfo processInfo
        environment 
        objectForKey:'HOME') 
       stringByAppendingPathComponent:'.bashrc')

\end{verbatim}
\caption{Cocoa convenience API for accessing file content}
\label{cocoa-file-contents}
\end{center}
\end{figure}


Which identifiers we can use in an oblivious style and which we need to
be aware of and resolve ourselves is usually pre-determined by the programming
language.
The same identifier that needs to be created using string processing from various
components in both the POSIX and the Cocoa can be written directly in a typical
Unix shell, including the variable part.

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
	cat $HOME/.basrhc
\end{verbatim}
\caption{File contents in a shell}
\label{sh-file-contents}
\end{center}
\end{figure}

The lack of string quotes is not just cosmetic: both the variable and the filename
are not just opaque strings, but entities that the shell is aware of and can identify
using the identifiers provided,for example being able to assist by autocomplete 
or wildcard expansion.

The large gap in the ease of talking about 
different types of objects is one of the motivations for Domain Specific Languages,
but integrating multiple

Such path-based access is not restricted to external resources, but also
prevalent when accessing dynamic data structures such as an XML DOM,
PDF objects 


\subsection{In-Memory Paths}





KVO, XML DOM Access, XPath, various types of PDF references, 

\subsection{Manipulating Identifiers}

User-interface wants to manipulate a particular part of an object, not the object that is 
currently there, therefore needs a runtime/symbolic representation of that location.
KVC/Bindings use strings, Smalltalk/Java ValueHolders use a level of indirection,
introducing user-level variables.


\subsection{Network Resources}

Distributed Objects




\subsection{The Trouble with Strings}

\epigraph{The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.}{Alan Perlis}


\epigraph{Trying to outsmart a compiler defeats much of the purpose of using one.}{Kernighan and Plauger, The Elements of Programming Style.}



\begin{itemize}

\item Processing the representation, details obscure intent
\item Mixing data and identifiers
\item Internationalization makes things (much) worse
\item Security, quoting, (SQL)-injection attacks

\end{itemize}



\section{Polymorphic Identifiers}
\epigraph{A change in perspective is worth 80 IQ points}{Alan Kay}



\begin{itemize}

\item URL syntax
\item User-level scheme resolvers
\item Mix of run-time / compile-time evaluation (can be fully runtime)
\item scheme:scheme to make resolvers part of the language and allow identifier-oblivious
	programming for user-defined identifiers
\item ref: to allow 

\end{itemize}


\section{Examples}

\section{Implementation}



Existing mechanisms for variable access via built-in identifiers not adequate in 
all domains, for example:
 \begin{itemize}

\item path-based access to various in-memory data structures (e.g. DOMs)
\item GUIs, serialization and notification mechanisms require treating a variable
	reference as a parameter.
\item external resources such as files and the web

\end{itemize}

Although these problems seem to be different from each other, we argue that they
have the same underlying cause:   lack of a first class identifiers.  

Coping mechanisms:  
\begin{itemize}
\item introduction of separate objects that act like identifiers
\item use of DSLs
\end{itemize}


\section{Related Work}

\subsection{LISP Quoting}

LISP quoting allows references to not be evaluated, but the returned value is just a symbol.

\subsection{E}

The E language adds URL for far references and some stuff

\subsection{ThingLab}

ThingLab adds path-based access to the base Smalltalk language in order to support
constraints referencing parts of objects, say the vertex of a triangle.   It does not
expand this path-based access to other domains or make it user-extensible.

\subsection{. references}



\subsection{Properties}

Properties in C\# and Objective-C 2.0 allow a variable-access interface to be backed by 
message sending, thus allowing path-based access 

\subsection{Icon}

In the Icon programming language, identifiers (references) can be first class values,
and there are complex rules for when a reference remains a reference and when
it's value is used.


\section{Summary and Outlook}



\appendix
\section{Appendix A}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
\bibliography{polymorphic-identifiers}


\end{document}
